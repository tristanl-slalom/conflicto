# Implementation Plan: Add Orval for automatic API client generation from OpenAPI spec

**GitHub Issue:** [#32](https://github.com/tristanl-slalom/conflicto/issues/32)
**Generated:** 2025-10-07T17:30:00Z

## Implementation Strategy

This implementation will use a phased approach to integrate Orval for automatic API client generation while maintaining existing functionality throughout the migration. The strategy prioritizes type safety, developer experience, and seamless integration with the current Caja architecture.

### High-Level Approach
1. **Non-Breaking Setup**: Install and configure Orval without affecting existing code
2. **Parallel Implementation**: Generate new API client alongside existing mock implementation
3. **Gradual Migration**: Update components one hook at a time to use generated code
4. **Testing Integration**: Ensure MSW mocks work with existing test suite
5. **Build Optimization**: Integrate generation into development and build workflows

## File Structure Changes

### New Files to Create
```
frontend/
├── orval.config.ts                          # Orval configuration
├── src/
│   ├── api/
│   │   ├── generated.ts                     # Generated API client (gitignored)
│   │   └── client.ts                        # HTTP client configuration
│   ├── mocks/
│   │   ├── handlers.ts                      # Generated MSW handlers (gitignored)
│   │   └── setup.ts                         # MSW setup configuration
│   └── types/
│       └── api.ts                           # Re-exported generated types
└── .gitignore                               # Updated to ignore generated files
```

### Files to Modify
```
frontend/
├── package.json                             # Add dependencies and scripts
├── vite.config.ts                           # Add Orval plugin for watch mode
├── vitest.config.ts                         # Configure MSW for tests
├── src/
│   ├── hooks/
│   │   └── useSession.ts                    # Migrate to generated hooks
│   └── __tests__/
│       └── setup.ts                         # Configure MSW for tests
```

## Implementation Steps

### Step 1: Dependencies and Configuration Setup
**Files:** `package.json`, `orval.config.ts`

#### Install Dependencies
```bash
# Core Orval dependencies
npm install --save-dev orval
```

#### Create Orval Configuration (`orval.config.ts`)
```typescript
import { defineConfig } from 'orval';

export default defineConfig({
  caja: {
    input: '../openapi.json',
    output: {
      mode: 'split',
      target: './src/api/generated.ts',
      schemas: './src/types/generated.ts',
      client: 'react-query',
      },
      mocks: true
    },
  },
});
```

#### Update Package Scripts (`package.json`)
```json
{
  "scripts": {
    "generate:api": "orval",
    "generate:api:watch": "orval --watch",
    "dev": "npm run generate:api && vite dev --port 3000",
    "build": "npm run generate:api && vite build",
    "test": "npm run generate:api && vitest run"
  }
}
```

### Step 2: HTTP Client Configuration
**Files:** `src/api/client.ts`

#### Create Custom Axios Instance
```typescript
import axios, { AxiosRequestConfig } from 'axios';

// Base configuration for Caja API
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';

export const customAxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for authentication (future)
customAxiosInstance.interceptors.request.use(
  (config) => {
    // Add auth headers when implemented
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
customAxiosInstance.interceptors.response.use(
  (response) => response.data,
  (error) => {
    // Handle common API errors
    if (error.response?.status === 401) {
      // Handle authentication errors
      console.warn('Authentication required');
    }
    return Promise.reject(error);
  }
);

// Custom mutator for Orval
export default <T = any>(config: AxiosRequestConfig): Promise<T> => {
  return customAxiosInstance(config);
};
```

### Step 3: MSW Integration for Testing
**Files:** `src/mocks/setup.ts`, `vitest.config.ts`, `src/__tests__/setup.ts`

#### MSW Setup Configuration (`src/mocks/setup.ts`)
```typescript
import { setupServer } from 'msw/node';
import { handlers } from './handlers'; // Generated by Orval

// Create MSW server with generated handlers
export const server = setupServer(...handlers);

// Start server for tests
export function setupMSW() {
  // Start server before all tests
  beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }));
  
  // Reset handlers after each test
  afterEach(() => server.resetHandlers());
  
  // Clean up after all tests
  afterAll(() => server.close());
}
```

#### Update Test Setup (`src/__tests__/setup.ts`)
```typescript
import '@testing-library/jest-dom';
import { setupMSW } from '../mocks/setup';

// Setup MSW for all tests
setupMSW();
```

#### Update Vitest Configuration (`vitest.config.ts`)
```typescript
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/__tests__/setup.ts'],
    globals: true,
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
});
```

### Step 4: Build Integration and Watch Mode
**Files:** `vite.config.ts`

#### Update Vite Configuration
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tsconfigPaths from 'vite-tsconfig-paths';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Custom plugin to regenerate API on OpenAPI changes
const orvalPlugin = () => ({
  name: 'orval-regenerate',
  async buildStart() {
    // Generate API client on build start
    await execAsync('npm run generate:api');
  },
  configureServer(server) {
    // Watch for OpenAPI changes in development
    server.watcher.add('../openapi.json');
    server.watcher.on('change', async (file) => {
      if (file.endsWith('openapi.json')) {
        console.log('OpenAPI spec changed, regenerating API client...');
        await execAsync('npm run generate:api');
        server.ws.send({ type: 'full-reload' });
      }
    });
  },
});

export default defineConfig({
  plugins: [
    react(),
    tsconfigPaths(),
    orvalPlugin(),
  ],
  server: {
    port: 3000,
    strictPort: true,
  },
});
```

### Step 5: Type Exports and Aliases
**Files:** `src/types/api.ts`

#### Create Type Export Barrel
```typescript
// Re-export generated types for easier imports
export * from './generated';
export * from '../api/generated';

// Type aliases for backward compatibility
export type { 
  SessionResponse as Session,
  SessionDetail as DetailedSession,
  SessionCreate as CreateSessionData,
  SessionUpdate as UpdateSessionData,
} from './generated';
```

### Step 6: Hook Migration Strategy
**Files:** `src/hooks/useSession.ts`

#### Gradual Migration Approach
```typescript
// Phase 1: Import generated hooks alongside existing ones
import {
  useListSessionsQuery,
  useGetSessionQuery,
  useCreateSessionMutation,
  useUpdateSessionMutation,
  useDeleteSessionMutation,
  useGetSessionByCodeQuery,
} from '../api/generated';

// Phase 2: Create wrapper hooks for backward compatibility
export function useSessions() {
  return useListSessionsQuery({ offset: 0, limit: 100 });
}

export function useSession(sessionId?: string) {
  return useGetSessionQuery(
    parseInt(sessionId || '0'),
    {
      enabled: !!sessionId && !isNaN(parseInt(sessionId)),
      staleTime: 30000,
    }
  );
}

// Phase 3: Update mutation hooks with proper error handling
export function useCreateSession() {
  const queryClient = useQueryClient();
  
  return useCreateSessionMutation({
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['sessions'] });
    },
  });
}

// Phase 4: Add polling for real-time updates
export function useSessionResponses(sessionId: string, enabled = false) {
  return useGetSessionQuery(
    parseInt(sessionId),
    {
      enabled: enabled && !!sessionId,
      refetchInterval: 2000, // Maintain 2-second polling
      staleTime: 1000,
    }
  );
}
```

### Step 7: Git Configuration Updates
**Files:** `.gitignore`

#### Update Git Ignore
```gitignore
# Generated API client files (regenerated from OpenAPI)
src/api/generated.ts
src/types/generated.ts
src/mocks/handlers.ts

# Orval cache
.orval-cache/
```

## Testing Strategy

### Unit Testing Approach
1. **Generated Hook Tests**: Test generated hooks with MSW mocks
2. **Component Integration Tests**: Verify components work with generated types
3. **Mock Validation Tests**: Ensure MSW handlers match OpenAPI spec
4. **Type Safety Tests**: Compile-time validation of generated types

### Test Files to Create
```
src/__tests__/
├── api/
│   ├── generated-hooks.test.ts             # Test generated React Query hooks
│   └── client.test.ts                      # Test HTTP client configuration
├── mocks/
│   └── handlers.test.ts                    # Validate MSW handlers
└── integration/
    └── session-workflow.test.ts            # End-to-end session management
```

### Example Test Implementation
```typescript
// src/__tests__/api/generated-hooks.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useListSessionsQuery, useCreateSessionMutation } from '../../api/generated';
import { server } from '../../mocks/setup';
import { rest } from 'msw';

describe('Generated API Hooks', () => {
  test('useListSessionsQuery returns session data', async () => {
    const queryClient = new QueryClient({
      defaultOptions: { queries: { retry: false } },
    });
    
    const { result } = renderHook(() => useListSessionsQuery(), {
      wrapper: ({ children }) => (
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      ),
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toMatchObject({
      sessions: expect.any(Array),
      total: expect.any(Number),
    });
  });
});
```

## Deployment Considerations

### Environment Configuration
- `VITE_API_BASE_URL` environment variable for different environments
- Production build must include API generation step
- CI/CD pipeline must have access to `openapi.json`

### Performance Optimizations
- Generated code should be tree-shakeable
- Lazy loading for large API responses
- Proper caching strategies for different endpoint types

### Monitoring and Error Handling
- API client errors should be properly typed
- Network failures should be handled gracefully
- Generated types should include proper error response types

## Risk Assessment

### Technical Risks
1. **Breaking Changes**: Generated code might break existing components
   - **Mitigation**: Gradual migration with backward-compatible wrappers

2. **Build Performance**: API generation might slow down builds
   - **Mitigation**: Caching and conditional generation

3. **Type Conflicts**: Generated types might conflict with existing types
   - **Mitigation**: Proper namespacing and gradual migration

### Development Risks
1. **Learning Curve**: Team needs to understand Orval configuration
   - **Mitigation**: Comprehensive documentation and examples

2. **Debugging Complexity**: Generated code harder to debug
   - **Mitigation**: Source maps and clear error messages

## Estimated Effort

### Time Estimation
- **Setup and Configuration**: 4-6 hours
- **HTTP Client and MSW Integration**: 2-3 hours  
- **Hook Migration and Testing**: 6-8 hours
- **Build Integration and Optimization**: 2-3 hours
- **Documentation and Examples**: 2-3 hours
- **Total Estimated Effort**: 16-23 hours (2-3 days)

### Complexity Assessment
- **Low Complexity**: Basic Orval setup and configuration
- **Medium Complexity**: MSW integration and build process updates
- **High Complexity**: Gradual migration strategy and type safety validation

This implementation plan ensures a smooth transition to generated API clients while maintaining existing functionality and improving developer experience with better type safety and reduced maintenance overhead.