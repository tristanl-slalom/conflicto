/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Caja Backend
 * Caja Live Event Engagement Platform Backend API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';
import type {
  RequestHandlerOptions
} from 'msw';

import { customFetcher } from './mutator';
/**
 * JSONB configuration data
 */
export type ActivityConfig = { [key: string]: unknown };

/**
 * Schema for Activity response.
 */
export interface Activity {
  /** Type of the activity */
  type: string;
  /** JSONB configuration data */
  config?: ActivityConfig;
  /** Order index for the activity */
  order_index?: number;
  id: string;
  session_id: number;
  status: ActivityStatus;
  created_at: string;
  updated_at: string;
}

/**
 * JSONB configuration data
 */
export type ActivityCreateConfig = { [key: string]: unknown };

/**
 * Status of the activity
 */
export type ActivityCreateStatus = ActivityStatus | null;

/**
 * Schema for creating a new Activity.
 */
export interface ActivityCreate {
  /** Type of the activity */
  type: string;
  /** JSONB configuration data */
  config?: ActivityCreateConfig;
  /** Order index for the activity */
  order_index?: number;
  /** Status of the activity */
  status?: ActivityCreateStatus;
}

/**
 * Schema for list of activities.
 */
export interface ActivityList {
  activities: Activity[];
  total: number;
}

export type ActivityResponseDescription = string | null;

export type ActivityResponseConfiguration = { [key: string]: unknown };

export type ActivityResponseStartedAt = string | null;

export type ActivityResponseCompletedAt = string | null;

/**
 * Activity response model.
 */
export interface ActivityResponse {
  id: number;
  created_at: string;
  updated_at: string;
  session_id: number;
  title: string;
  description: ActivityResponseDescription;
  activity_type: ActivityType;
  configuration: ActivityResponseConfiguration;
  is_active: boolean;
  order_index: number;
  started_at: ActivityResponseStartedAt;
  completed_at: ActivityResponseCompletedAt;
  response_count?: number;
}

/**
 * Response data from participant
 */
export type ActivityResponseSubmissionRequestResponseData = { [key: string]: unknown };

/**
 * Framework activity response submission request.
 */
export interface ActivityResponseSubmissionRequest {
  /** Response data from participant */
  response_data: ActivityResponseSubmissionRequestResponseData;
}

/**
 * Calculated activity results
 */
export type ActivityResultsResponseResults = { [key: string]: unknown };

/**
 * Activity results response.
 */
export interface ActivityResultsResponse {
  /** Calculated activity results */
  results: ActivityResultsResponseResults;
  /** When results were last calculated */
  last_updated: string;
}

/**
 * Activity status enumeration.
 */
export type ActivityStatus = typeof ActivityStatus[keyof typeof ActivityStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActivityStatus = {
  draft: 'draft',
  active: 'active',
  completed: 'completed',
  cancelled: 'cancelled',
} as const;

export type ActivityStatusResponseLastResponseAt = string | null;

/**
 * Activity status for real-time polling.
 */
export interface ActivityStatusResponse {
  activity_id: string;
  status: ActivityStatus;
  response_count: number;
  last_response_at?: ActivityStatusResponseLastResponseAt;
  last_updated: string;
}

/**
 * Optional reason for the transition
 */
export type ActivityTransitionRequestReason = string | null;

/**
 * Activity state transition request.
 */
export interface ActivityTransitionRequest {
  /**
   * Target state to transition to
   * @pattern ^(draft|published|active|expired)$
   */
  target_state: string;
  /** Optional reason for the transition */
  reason?: ActivityTransitionRequestReason;
  /** Force transition (skip validation) */
  force?: boolean;
}

/**
 * Activity type enumeration.
 */
export type ActivityType = typeof ActivityType[keyof typeof ActivityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActivityType = {
  poll: 'poll',
  word_cloud: 'word_cloud',
  qa: 'qa',
  planning_poker: 'planning_poker',
} as const;

/**
 * Activity type information response.
 */
export interface ActivityTypeResponse {
  /** Unique activity type identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Description of the activity type */
  description: string;
  /** Activity type version */
  version: string;
}

/**
 * JSON schema for activity configuration
 */
export type ActivityTypeSchemaResponseSchema = { [key: string]: unknown };

/**
 * Activity type schema response.
 */
export interface ActivityTypeSchemaResponse {
  /** Activity type identifier */
  activity_type: string;
  /** JSON schema for activity configuration */
  schema: ActivityTypeSchemaResponseSchema;
}

/**
 * List of available activity types response.
 */
export interface ActivityTypesListResponse {
  activity_types: ActivityTypeResponse[];
}

export type ActivityUpdateType = string | null;

export type ActivityUpdateConfigAnyOf = { [key: string]: unknown };

export type ActivityUpdateConfig = ActivityUpdateConfigAnyOf | null;

export type ActivityUpdateOrderIndex = number | null;

export type ActivityUpdateStatus = ActivityStatus | null;

/**
 * Schema for updating an Activity.
 */
export interface ActivityUpdate {
  type?: ActivityUpdateType;
  config?: ActivityUpdateConfig;
  order_index?: ActivityUpdateOrderIndex;
  status?: ActivityUpdateStatus;
}

/**
 * Configuration to validate
 */
export type ActivityValidationRequestConfiguration = { [key: string]: unknown };

/**
 * Activity configuration validation request.
 */
export interface ActivityValidationRequest {
  /** Activity type identifier */
  activity_type: string;
  /** Configuration to validate */
  configuration: ActivityValidationRequestConfiguration;
}

/**
 * Activity configuration validation response.
 */
export interface ActivityValidationResponse {
  /** Whether the configuration is valid */
  valid: boolean;
  /** List of validation errors */
  errors?: string[];
  /** List of validation warnings */
  warnings?: string[];
}

/**
 * Error response model.
 */
export interface ErrorResponse {
  detail: string;
  error_type?: string;
  timestamp?: string;
}

/**
 * Optional activity description
 */
export type FrameworkActivityCreateDescription = string | null;

/**
 * Activity-specific configuration
 */
export type FrameworkActivityCreateConfiguration = { [key: string]: unknown };

export type FrameworkActivityCreateActivityMetadataAnyOf = { [key: string]: unknown };

/**
 * Framework metadata
 */
export type FrameworkActivityCreateActivityMetadata = FrameworkActivityCreateActivityMetadataAnyOf | null;

/**
 * Framework-enhanced activity creation request.
 */
export interface FrameworkActivityCreate {
  /** Type of activity to create */
  activity_type: string;
  /**
   * Activity title
   * @minLength 1
   * @maxLength 500
   */
  title: string;
  /** Optional activity description */
  description?: FrameworkActivityCreateDescription;
  /** Activity-specific configuration */
  configuration?: FrameworkActivityCreateConfiguration;
  /** Framework metadata */
  activity_metadata?: FrameworkActivityCreateActivityMetadata;
  /**
   * Order index for the activity
   * @minimum 0
   */
  order_index?: number;
}

/**
 * When activity expires
 */
export type FrameworkActivityStatusResponseExpiresAt = string | null;

/**
 * Activity metadata
 */
export type FrameworkActivityStatusResponseActivityMetadata = { [key: string]: unknown };

export type FrameworkActivityStatusResponseResultsAnyOf = { [key: string]: unknown };

/**
 * Calculated results if available
 */
export type FrameworkActivityStatusResponseResults = FrameworkActivityStatusResponseResultsAnyOf | null;

/**
 * Last response timestamp
 */
export type FrameworkActivityStatusResponseLastResponseAt = string | null;

/**
 * Enhanced activity status response with framework information.
 */
export interface FrameworkActivityStatusResponse {
  /** Activity ID */
  activity_id: string;
  /** Legacy activity status */
  status: ActivityStatus;
  /** Framework activity state */
  state: string;
  /** Number of responses */
  response_count: number;
  /** When activity expires */
  expires_at?: FrameworkActivityStatusResponseExpiresAt;
  /** Activity metadata */
  activity_metadata?: FrameworkActivityStatusResponseActivityMetadata;
  /** Valid state transitions */
  valid_transitions?: string[];
  /** Calculated results if available */
  results?: FrameworkActivityStatusResponseResults;
  /** Last response timestamp */
  last_response_at?: FrameworkActivityStatusResponseLastResponseAt;
  /** Last update timestamp */
  last_updated: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Health check response model.
 */
export interface HealthResponse {
  status?: string;
  timestamp?: string;
  version?: string;
}

/**
 * Schema for incremental response updates since timestamp.
 */
export interface IncrementalResponseList {
  items?: UserResponse[];
  since: string;
  count: number;
}

export type NicknameValidationResponseSuggestedNickname = string | null;

/**
 * Nickname validation response model.
 */
export interface NicknameValidationResponse {
  available: boolean;
  suggested_nickname?: NicknameValidationResponseSuggestedNickname;
}

export type ParticipantHeartbeatRequestActivityContextAnyOf = { [key: string]: unknown };

export type ParticipantHeartbeatRequestActivityContext = ParticipantHeartbeatRequestActivityContextAnyOf | null;

/**
 * Participant heartbeat request model.
 */
export interface ParticipantHeartbeatRequest {
  activity_context?: ParticipantHeartbeatRequestActivityContext;
}

export type ParticipantHeartbeatResponseActivityContext = { [key: string]: unknown };

/**
 * Participant heartbeat response model.
 */
export interface ParticipantHeartbeatResponse {
  status: string;
  activity_context: ParticipantHeartbeatResponseActivityContext;
  updated_at: string;
}

/**
 * Session join request model.
 */
export interface ParticipantJoinRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  nickname: string;
}

export type ParticipantJoinResponseSessionState = { [key: string]: unknown };

/**
 * Session join response model.
 */
export interface ParticipantJoinResponse {
  participant_id: string;
  session_state: ParticipantJoinResponseSessionState;
}

/**
 * Participant list response model.
 */
export interface ParticipantListResponse {
  participants: ParticipantStatus[];
  total_count: number;
}

/**
 * Computed participant status model.
 */
export interface ParticipantStatus {
  participant_id: string;
  nickname: string;
  status: string;
  joined_at: string;
  last_seen: string;
}

export type SessionCreateDescription = string | null;

/**
 * Session creation request model.
 */
export interface SessionCreate {
  /**
   * @minLength 1
   * @maxLength 255
   */
  title: string;
  description?: SessionCreateDescription;
  /**
   * @minimum 1
   * @maximum 1000
   */
  max_participants?: number;
}

export type SessionDetailDescription = string | null;

export type SessionDetailQrCode = string | null;

export type SessionDetailAdminCode = string | null;

export type SessionDetailStartedAt = string | null;

export type SessionDetailCompletedAt = string | null;

/**
 * Detailed session response with activities and participants.
 */
export interface SessionDetail {
  id: number;
  created_at: string;
  updated_at: string;
  title: string;
  description: SessionDetailDescription;
  status: SessionStatus;
  qr_code: SessionDetailQrCode;
  admin_code: SessionDetailAdminCode;
  max_participants: number;
  started_at: SessionDetailStartedAt;
  completed_at: SessionDetailCompletedAt;
  participant_count?: number;
  activity_count?: number;
  activities?: ActivityResponse[];
  participants?: ParticipantStatus[];
}

/**
 * Session list response model.
 */
export interface SessionList {
  sessions: SessionResponse[];
  total: number;
  offset: number;
  limit: number;
}

export type SessionResponseDescription = string | null;

export type SessionResponseQrCode = string | null;

export type SessionResponseAdminCode = string | null;

export type SessionResponseStartedAt = string | null;

export type SessionResponseCompletedAt = string | null;

/**
 * Session response model.
 */
export interface SessionResponse {
  id: number;
  created_at: string;
  updated_at: string;
  title: string;
  description: SessionResponseDescription;
  status: SessionStatus;
  qr_code: SessionResponseQrCode;
  admin_code: SessionResponseAdminCode;
  max_participants: number;
  started_at: SessionResponseStartedAt;
  completed_at: SessionResponseCompletedAt;
  participant_count?: number;
  activity_count?: number;
}

/**
 * Session status enumeration.
 */
export type SessionStatus = typeof SessionStatus[keyof typeof SessionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionStatus = {
  draft: 'draft',
  active: 'active',
  completed: 'completed',
} as const;

export type SessionStatusResponseCurrentActivityId = string | null;

/**
 * Session status for real-time polling.
 */
export interface SessionStatusResponse {
  session_id: number;
  status: SessionStatus;
  current_activity_id?: SessionStatusResponseCurrentActivityId;
  participant_count: number;
  last_updated: string;
}

export type SessionUpdateTitle = string | null;

export type SessionUpdateDescription = string | null;

export type SessionUpdateMaxParticipants = number | null;

export type SessionUpdateStatus = SessionStatus | null;

/**
 * Session update request model.
 */
export interface SessionUpdate {
  title?: SessionUpdateTitle;
  description?: SessionUpdateDescription;
  max_participants?: SessionUpdateMaxParticipants;
  status?: SessionUpdateStatus;
}

/**
 * Activity-specific response data in JSON format
 */
export type UserResponseResponseData = { [key: string]: unknown };

/**
 * Schema for User Response with all fields.
 */
export interface UserResponse {
  /** Activity-specific response data in JSON format */
  response_data: UserResponseResponseData;
  id: string;
  session_id: number;
  activity_id: string;
  participant_id: number;
  created_at: string;
  updated_at: string;
}

/**
 * Activity-specific response data in JSON format
 */
export type UserResponseCreateResponseData = { [key: string]: unknown };

/**
 * Schema for creating a User Response.
 */
export interface UserResponseCreate {
  /** Activity-specific response data in JSON format */
  response_data: UserResponseCreateResponseData;
}

/**
 * Schema for paginated User Response list with summary.
 */
export interface UserResponseList {
  responses: UserResponse[];
  summary: UserResponseSummary;
}

export type UserResponseSummaryLastUpdated = string | null;

/**
 * Schema for User Response summary statistics.
 */
export interface UserResponseSummary {
  total_responses: number;
  unique_participants: number;
  last_updated: UserResponseSummaryLastUpdated;
}

/**
 * Activity-specific response data in JSON format
 */
export type UserResponseUpdateResponseData = { [key: string]: unknown };

/**
 * Schema for updating a User Response.
 */
export interface UserResponseUpdate {
  /** Activity-specific response data in JSON format */
  response_data: UserResponseUpdateResponseData;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type ListSessionsApiV1SessionsGetParams = {
offset?: number;
limit?: number;
};

export type GetSessionByCodeApiV1SessionsCodeCodeGetParams = {
code_type?: string;
};

export type ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams = {
/**
 * @minLength 1
 * @maxLength 50
 */
nickname: string;
};

export type CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams = {
participant_id: number;
};

export type GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams = {
/**
 * @minimum 0
 */
offset?: number;
/**
 * @minimum 1
 * @maximum 1000
 */
limit?: number;
};

export type GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet200 = UserResponse | null;

export type GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams = {
/**
 * @minimum 0
 */
offset?: number;
/**
 * @minimum 1
 * @maximum 1000
 */
limit?: number;
};

export type GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams = {
/**
 * @minimum 1
 * @maximum 10000
 */
limit?: number;
};

export type GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams = {
/**
 * @minimum 0
 */
offset?: number;
/**
 * @minimum 1
 * @maximum 1000
 */
limit?: number;
/**
 * Filter activities by status
 */
status?: ActivityStatus | null;
};

export type UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams = {
status: ActivityStatus;
};

export type GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet200 = Activity | null;

export type SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams = {
participant_id: number;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Health check endpoint.

Returns service health status and checks database connectivity.
 * @summary Health Check
 */
export type healthCheckApiV1HealthGetResponse200 = {
  data: HealthResponse
  status: 200
}

export type healthCheckApiV1HealthGetResponse503 = {
  data: ErrorResponse
  status: 503
}

export type healthCheckApiV1HealthGetResponseSuccess = (healthCheckApiV1HealthGetResponse200) & {
  headers: Headers;
};
export type healthCheckApiV1HealthGetResponseError = (healthCheckApiV1HealthGetResponse503) & {
  headers: Headers;
};

export type healthCheckApiV1HealthGetResponse = (healthCheckApiV1HealthGetResponseSuccess | healthCheckApiV1HealthGetResponseError)

export const getHealthCheckApiV1HealthGetUrl = () => {




  return `/api/v1/health/`
}

export const healthCheckApiV1HealthGet = async ( options?: RequestInit): Promise<healthCheckApiV1HealthGetResponse> => {

  return customFetcher<healthCheckApiV1HealthGetResponse>(getHealthCheckApiV1HealthGetUrl(),
  {
    ...options,
    method: 'GET'


  }
);}





export const getHealthCheckApiV1HealthGetQueryKey = () => {
    return [
    `/api/v1/health/`
    ] as const;
    }


export const getHealthCheckApiV1HealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckApiV1HealthGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>> = ({ signal }) => healthCheckApiV1HealthGet({ signal, ...requestOptions });





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckApiV1HealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>>
export type HealthCheckApiV1HealthGetQueryError = ErrorResponse


export function useHealthCheckApiV1HealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckApiV1HealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckApiV1HealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckApiV1HealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1HealthGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckApiV1HealthGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Readiness check endpoint.

Returns whether the service is ready to accept requests.
 * @summary Readiness Check
 */
export type readinessCheckApiV1HealthReadyGetResponse200 = {
  data: HealthResponse
  status: 200
}

export type readinessCheckApiV1HealthReadyGetResponseSuccess = (readinessCheckApiV1HealthReadyGetResponse200) & {
  headers: Headers;
};
;

export type readinessCheckApiV1HealthReadyGetResponse = (readinessCheckApiV1HealthReadyGetResponseSuccess)

export const getReadinessCheckApiV1HealthReadyGetUrl = () => {




  return `/api/v1/health/ready`
}

export const readinessCheckApiV1HealthReadyGet = async ( options?: RequestInit): Promise<readinessCheckApiV1HealthReadyGetResponse> => {

  return customFetcher<readinessCheckApiV1HealthReadyGetResponse>(getReadinessCheckApiV1HealthReadyGetUrl(),
  {
    ...options,
    method: 'GET'


  }
);}





export const getReadinessCheckApiV1HealthReadyGetQueryKey = () => {
    return [
    `/api/v1/health/ready`
    ] as const;
    }


export const getReadinessCheckApiV1HealthReadyGetQueryOptions = <TData = Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadinessCheckApiV1HealthReadyGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>> = ({ signal }) => readinessCheckApiV1HealthReadyGet({ signal, ...requestOptions });





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadinessCheckApiV1HealthReadyGetQueryResult = NonNullable<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>>
export type ReadinessCheckApiV1HealthReadyGetQueryError = unknown


export function useReadinessCheckApiV1HealthReadyGet<TData = Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>,
          TError,
          Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadinessCheckApiV1HealthReadyGet<TData = Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>,
          TError,
          Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadinessCheckApiV1HealthReadyGet<TData = Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Readiness Check
 */

export function useReadinessCheckApiV1HealthReadyGet<TData = Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readinessCheckApiV1HealthReadyGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadinessCheckApiV1HealthReadyGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Liveness check endpoint.

Returns whether the service is alive and running.
 * @summary Liveness Check
 */
export type livenessCheckApiV1HealthLiveGetResponse200 = {
  data: HealthResponse
  status: 200
}

export type livenessCheckApiV1HealthLiveGetResponseSuccess = (livenessCheckApiV1HealthLiveGetResponse200) & {
  headers: Headers;
};
;

export type livenessCheckApiV1HealthLiveGetResponse = (livenessCheckApiV1HealthLiveGetResponseSuccess)

export const getLivenessCheckApiV1HealthLiveGetUrl = () => {




  return `/api/v1/health/live`
}

export const livenessCheckApiV1HealthLiveGet = async ( options?: RequestInit): Promise<livenessCheckApiV1HealthLiveGetResponse> => {

  return customFetcher<livenessCheckApiV1HealthLiveGetResponse>(getLivenessCheckApiV1HealthLiveGetUrl(),
  {
    ...options,
    method: 'GET'


  }
);}





export const getLivenessCheckApiV1HealthLiveGetQueryKey = () => {
    return [
    `/api/v1/health/live`
    ] as const;
    }


export const getLivenessCheckApiV1HealthLiveGetQueryOptions = <TData = Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLivenessCheckApiV1HealthLiveGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>> = ({ signal }) => livenessCheckApiV1HealthLiveGet({ signal, ...requestOptions });





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LivenessCheckApiV1HealthLiveGetQueryResult = NonNullable<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>>
export type LivenessCheckApiV1HealthLiveGetQueryError = unknown


export function useLivenessCheckApiV1HealthLiveGet<TData = Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>,
          TError,
          Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLivenessCheckApiV1HealthLiveGet<TData = Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>,
          TError,
          Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLivenessCheckApiV1HealthLiveGet<TData = Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Liveness Check
 */

export function useLivenessCheckApiV1HealthLiveGet<TData = Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof livenessCheckApiV1HealthLiveGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLivenessCheckApiV1HealthLiveGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new session.

Creates a new live event session with generated QR and admin codes.
The session starts in DRAFT status.
 * @summary Create Session
 */
export type createSessionApiV1SessionsPostResponse201 = {
  data: SessionResponse
  status: 201
}

export type createSessionApiV1SessionsPostResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createSessionApiV1SessionsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createSessionApiV1SessionsPostResponseSuccess = (createSessionApiV1SessionsPostResponse201) & {
  headers: Headers;
};
export type createSessionApiV1SessionsPostResponseError = (createSessionApiV1SessionsPostResponse400 | createSessionApiV1SessionsPostResponse422) & {
  headers: Headers;
};

export type createSessionApiV1SessionsPostResponse = (createSessionApiV1SessionsPostResponseSuccess | createSessionApiV1SessionsPostResponseError)

export const getCreateSessionApiV1SessionsPostUrl = () => {




  return `/api/v1/sessions/`
}

export const createSessionApiV1SessionsPost = async (sessionCreate: SessionCreate, options?: RequestInit): Promise<createSessionApiV1SessionsPostResponse> => {

  return customFetcher<createSessionApiV1SessionsPostResponse>(getCreateSessionApiV1SessionsPostUrl(),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessionCreate,)
  }
);}




export const getCreateSessionApiV1SessionsPostMutationOptions = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSessionApiV1SessionsPost>>, TError,{data: SessionCreate}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createSessionApiV1SessionsPost>>, TError,{data: SessionCreate}, TContext> => {

const mutationKey = ['createSessionApiV1SessionsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSessionApiV1SessionsPost>>, {data: SessionCreate}> = (props) => {
          const {data} = props ?? {};

          return  createSessionApiV1SessionsPost(data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionApiV1SessionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createSessionApiV1SessionsPost>>>
    export type CreateSessionApiV1SessionsPostMutationBody = SessionCreate
    export type CreateSessionApiV1SessionsPostMutationError = ErrorResponse | HTTPValidationError

    /**
 * @summary Create Session
 */
export const useCreateSessionApiV1SessionsPost = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSessionApiV1SessionsPost>>, TError,{data: SessionCreate}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSessionApiV1SessionsPost>>,
        TError,
        {data: SessionCreate},
        TContext
      > => {

      const mutationOptions = getCreateSessionApiV1SessionsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * List all sessions with pagination.

Returns a paginated list of all sessions, ordered by creation date (newest first).
 * @summary List Sessions
 */
export type listSessionsApiV1SessionsGetResponse200 = {
  data: SessionList
  status: 200
}

export type listSessionsApiV1SessionsGetResponse400 = {
  data: ErrorResponse
  status: 400
}

export type listSessionsApiV1SessionsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listSessionsApiV1SessionsGetResponseSuccess = (listSessionsApiV1SessionsGetResponse200) & {
  headers: Headers;
};
export type listSessionsApiV1SessionsGetResponseError = (listSessionsApiV1SessionsGetResponse400 | listSessionsApiV1SessionsGetResponse422) & {
  headers: Headers;
};

export type listSessionsApiV1SessionsGetResponse = (listSessionsApiV1SessionsGetResponseSuccess | listSessionsApiV1SessionsGetResponseError)

export const getListSessionsApiV1SessionsGetUrl = (params?: ListSessionsApiV1SessionsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/?${stringifiedParams}` : `/api/v1/sessions/`
}

export const listSessionsApiV1SessionsGet = async (params?: ListSessionsApiV1SessionsGetParams, options?: RequestInit): Promise<listSessionsApiV1SessionsGetResponse> => {

  return customFetcher<listSessionsApiV1SessionsGetResponse>(getListSessionsApiV1SessionsGetUrl(params),
  {
    ...options,
    method: 'GET'


  }
);}





export const getListSessionsApiV1SessionsGetQueryKey = (params?: ListSessionsApiV1SessionsGetParams,) => {
    return [
    `/api/v1/sessions/`, ...(params ? [params]: [])
    ] as const;
    }


export const getListSessionsApiV1SessionsGetQueryOptions = <TData = Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError = ErrorResponse | HTTPValidationError>(params?: ListSessionsApiV1SessionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSessionsApiV1SessionsGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>> = ({ signal }) => listSessionsApiV1SessionsGet(params, { signal, ...requestOptions });





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSessionsApiV1SessionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>>
export type ListSessionsApiV1SessionsGetQueryError = ErrorResponse | HTTPValidationError


export function useListSessionsApiV1SessionsGet<TData = Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError = ErrorResponse | HTTPValidationError>(
 params: undefined |  ListSessionsApiV1SessionsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>,
          TError,
          Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSessionsApiV1SessionsGet<TData = Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError = ErrorResponse | HTTPValidationError>(
 params?: ListSessionsApiV1SessionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>,
          TError,
          Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSessionsApiV1SessionsGet<TData = Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError = ErrorResponse | HTTPValidationError>(
 params?: ListSessionsApiV1SessionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Sessions
 */

export function useListSessionsApiV1SessionsGet<TData = Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError = ErrorResponse | HTTPValidationError>(
 params?: ListSessionsApiV1SessionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessionsApiV1SessionsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSessionsApiV1SessionsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get detailed session information.

Returns complete session details including activities and participants.
 * @summary Get Session
 */
export type getSessionApiV1SessionsSessionIdGetResponse200 = {
  data: SessionDetail
  status: 200
}

export type getSessionApiV1SessionsSessionIdGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getSessionApiV1SessionsSessionIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getSessionApiV1SessionsSessionIdGetResponseSuccess = (getSessionApiV1SessionsSessionIdGetResponse200) & {
  headers: Headers;
};
export type getSessionApiV1SessionsSessionIdGetResponseError = (getSessionApiV1SessionsSessionIdGetResponse404 | getSessionApiV1SessionsSessionIdGetResponse422) & {
  headers: Headers;
};

export type getSessionApiV1SessionsSessionIdGetResponse = (getSessionApiV1SessionsSessionIdGetResponseSuccess | getSessionApiV1SessionsSessionIdGetResponseError)

export const getGetSessionApiV1SessionsSessionIdGetUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}`
}

export const getSessionApiV1SessionsSessionIdGet = async (sessionId: number, options?: RequestInit): Promise<getSessionApiV1SessionsSessionIdGetResponse> => {

  return customFetcher<getSessionApiV1SessionsSessionIdGetResponse>(getGetSessionApiV1SessionsSessionIdGetUrl(sessionId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetSessionApiV1SessionsSessionIdGetQueryKey = (sessionId?: number,) => {
    return [
    `/api/v1/sessions/${sessionId}`
    ] as const;
    }


export const getGetSessionApiV1SessionsSessionIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError = ErrorResponse | HTTPValidationError>(sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionApiV1SessionsSessionIdGetQueryKey(sessionId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>> = ({ signal }) => getSessionApiV1SessionsSessionIdGet(sessionId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionApiV1SessionsSessionIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>>
export type GetSessionApiV1SessionsSessionIdGetQueryError = ErrorResponse | HTTPValidationError


export function useGetSessionApiV1SessionsSessionIdGet<TData = Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionApiV1SessionsSessionIdGet<TData = Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionApiV1SessionsSessionIdGet<TData = Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Session
 */

export function useGetSessionApiV1SessionsSessionIdGet<TData = Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionApiV1SessionsSessionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionApiV1SessionsSessionIdGetQueryOptions(sessionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing session.

Updates session details. Status transitions are tracked with timestamps.
 * @summary Update Session
 */
export type updateSessionApiV1SessionsSessionIdPutResponse200 = {
  data: SessionResponse
  status: 200
}

export type updateSessionApiV1SessionsSessionIdPutResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateSessionApiV1SessionsSessionIdPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateSessionApiV1SessionsSessionIdPutResponseSuccess = (updateSessionApiV1SessionsSessionIdPutResponse200) & {
  headers: Headers;
};
export type updateSessionApiV1SessionsSessionIdPutResponseError = (updateSessionApiV1SessionsSessionIdPutResponse404 | updateSessionApiV1SessionsSessionIdPutResponse422) & {
  headers: Headers;
};

export type updateSessionApiV1SessionsSessionIdPutResponse = (updateSessionApiV1SessionsSessionIdPutResponseSuccess | updateSessionApiV1SessionsSessionIdPutResponseError)

export const getUpdateSessionApiV1SessionsSessionIdPutUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}`
}

export const updateSessionApiV1SessionsSessionIdPut = async (sessionId: number,
    sessionUpdate: SessionUpdate, options?: RequestInit): Promise<updateSessionApiV1SessionsSessionIdPutResponse> => {

  return customFetcher<updateSessionApiV1SessionsSessionIdPutResponse>(getUpdateSessionApiV1SessionsSessionIdPutUrl(sessionId),
  {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessionUpdate,)
  }
);}




export const getUpdateSessionApiV1SessionsSessionIdPutMutationOptions = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSessionApiV1SessionsSessionIdPut>>, TError,{sessionId: number;data: SessionUpdate}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSessionApiV1SessionsSessionIdPut>>, TError,{sessionId: number;data: SessionUpdate}, TContext> => {

const mutationKey = ['updateSessionApiV1SessionsSessionIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSessionApiV1SessionsSessionIdPut>>, {sessionId: number;data: SessionUpdate}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateSessionApiV1SessionsSessionIdPut(sessionId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateSessionApiV1SessionsSessionIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateSessionApiV1SessionsSessionIdPut>>>
    export type UpdateSessionApiV1SessionsSessionIdPutMutationBody = SessionUpdate
    export type UpdateSessionApiV1SessionsSessionIdPutMutationError = ErrorResponse | HTTPValidationError

    /**
 * @summary Update Session
 */
export const useUpdateSessionApiV1SessionsSessionIdPut = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSessionApiV1SessionsSessionIdPut>>, TError,{sessionId: number;data: SessionUpdate}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSessionApiV1SessionsSessionIdPut>>,
        TError,
        {sessionId: number;data: SessionUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateSessionApiV1SessionsSessionIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Delete a session.

Permanently deletes a session and all associated data (activities, participants, responses).
 * @summary Delete Session
 */
export type deleteSessionApiV1SessionsSessionIdDeleteResponse204 = {
  data: void
  status: 204
}

export type deleteSessionApiV1SessionsSessionIdDeleteResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteSessionApiV1SessionsSessionIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteSessionApiV1SessionsSessionIdDeleteResponseSuccess = (deleteSessionApiV1SessionsSessionIdDeleteResponse204) & {
  headers: Headers;
};
export type deleteSessionApiV1SessionsSessionIdDeleteResponseError = (deleteSessionApiV1SessionsSessionIdDeleteResponse404 | deleteSessionApiV1SessionsSessionIdDeleteResponse422) & {
  headers: Headers;
};

export type deleteSessionApiV1SessionsSessionIdDeleteResponse = (deleteSessionApiV1SessionsSessionIdDeleteResponseSuccess | deleteSessionApiV1SessionsSessionIdDeleteResponseError)

export const getDeleteSessionApiV1SessionsSessionIdDeleteUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}`
}

export const deleteSessionApiV1SessionsSessionIdDelete = async (sessionId: number, options?: RequestInit): Promise<deleteSessionApiV1SessionsSessionIdDeleteResponse> => {

  return customFetcher<deleteSessionApiV1SessionsSessionIdDeleteResponse>(getDeleteSessionApiV1SessionsSessionIdDeleteUrl(sessionId),
  {
    ...options,
    method: 'DELETE'


  }
);}




export const getDeleteSessionApiV1SessionsSessionIdDeleteMutationOptions = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSessionApiV1SessionsSessionIdDelete>>, TError,{sessionId: number}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSessionApiV1SessionsSessionIdDelete>>, TError,{sessionId: number}, TContext> => {

const mutationKey = ['deleteSessionApiV1SessionsSessionIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSessionApiV1SessionsSessionIdDelete>>, {sessionId: number}> = (props) => {
          const {sessionId} = props ?? {};

          return  deleteSessionApiV1SessionsSessionIdDelete(sessionId,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteSessionApiV1SessionsSessionIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSessionApiV1SessionsSessionIdDelete>>>

    export type DeleteSessionApiV1SessionsSessionIdDeleteMutationError = ErrorResponse | HTTPValidationError

    /**
 * @summary Delete Session
 */
export const useDeleteSessionApiV1SessionsSessionIdDelete = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSessionApiV1SessionsSessionIdDelete>>, TError,{sessionId: number}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSessionApiV1SessionsSessionIdDelete>>,
        TError,
        {sessionId: number},
        TContext
      > => {

      const mutationOptions = getDeleteSessionApiV1SessionsSessionIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get session by QR code or admin code.

Allows participants to join via QR code or admins to access via admin code.
 * @summary Get Session By Code
 */
export type getSessionByCodeApiV1SessionsCodeCodeGetResponse200 = {
  data: SessionResponse
  status: 200
}

export type getSessionByCodeApiV1SessionsCodeCodeGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getSessionByCodeApiV1SessionsCodeCodeGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getSessionByCodeApiV1SessionsCodeCodeGetResponseSuccess = (getSessionByCodeApiV1SessionsCodeCodeGetResponse200) & {
  headers: Headers;
};
export type getSessionByCodeApiV1SessionsCodeCodeGetResponseError = (getSessionByCodeApiV1SessionsCodeCodeGetResponse404 | getSessionByCodeApiV1SessionsCodeCodeGetResponse422) & {
  headers: Headers;
};

export type getSessionByCodeApiV1SessionsCodeCodeGetResponse = (getSessionByCodeApiV1SessionsCodeCodeGetResponseSuccess | getSessionByCodeApiV1SessionsCodeCodeGetResponseError)

export const getGetSessionByCodeApiV1SessionsCodeCodeGetUrl = (code: string,
    params?: GetSessionByCodeApiV1SessionsCodeCodeGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/code/${code}?${stringifiedParams}` : `/api/v1/sessions/code/${code}`
}

export const getSessionByCodeApiV1SessionsCodeCodeGet = async (code: string,
    params?: GetSessionByCodeApiV1SessionsCodeCodeGetParams, options?: RequestInit): Promise<getSessionByCodeApiV1SessionsCodeCodeGetResponse> => {

  return customFetcher<getSessionByCodeApiV1SessionsCodeCodeGetResponse>(getGetSessionByCodeApiV1SessionsCodeCodeGetUrl(code,params),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetSessionByCodeApiV1SessionsCodeCodeGetQueryKey = (code?: string,
    params?: GetSessionByCodeApiV1SessionsCodeCodeGetParams,) => {
    return [
    `/api/v1/sessions/code/${code}`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetSessionByCodeApiV1SessionsCodeCodeGetQueryOptions = <TData = Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError = ErrorResponse | HTTPValidationError>(code: string,
    params?: GetSessionByCodeApiV1SessionsCodeCodeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionByCodeApiV1SessionsCodeCodeGetQueryKey(code,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>> = ({ signal }) => getSessionByCodeApiV1SessionsCodeCodeGet(code,params, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionByCodeApiV1SessionsCodeCodeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>>
export type GetSessionByCodeApiV1SessionsCodeCodeGetQueryError = ErrorResponse | HTTPValidationError


export function useGetSessionByCodeApiV1SessionsCodeCodeGet<TData = Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError = ErrorResponse | HTTPValidationError>(
 code: string,
    params: undefined |  GetSessionByCodeApiV1SessionsCodeCodeGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionByCodeApiV1SessionsCodeCodeGet<TData = Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError = ErrorResponse | HTTPValidationError>(
 code: string,
    params?: GetSessionByCodeApiV1SessionsCodeCodeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionByCodeApiV1SessionsCodeCodeGet<TData = Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError = ErrorResponse | HTTPValidationError>(
 code: string,
    params?: GetSessionByCodeApiV1SessionsCodeCodeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Session By Code
 */

export function useGetSessionByCodeApiV1SessionsCodeCodeGet<TData = Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError = ErrorResponse | HTTPValidationError>(
 code: string,
    params?: GetSessionByCodeApiV1SessionsCodeCodeGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionByCodeApiV1SessionsCodeCodeGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionByCodeApiV1SessionsCodeCodeGetQueryOptions(code,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get real-time session status for polling.

Returns current session status, active activity, participant count,
and last update timestamp for efficient polling.
 * @summary Get Session Status
 */
export type getSessionStatusApiV1SessionsSessionIdStatusGetResponse200 = {
  data: SessionStatusResponse
  status: 200
}

export type getSessionStatusApiV1SessionsSessionIdStatusGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getSessionStatusApiV1SessionsSessionIdStatusGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getSessionStatusApiV1SessionsSessionIdStatusGetResponseSuccess = (getSessionStatusApiV1SessionsSessionIdStatusGetResponse200) & {
  headers: Headers;
};
export type getSessionStatusApiV1SessionsSessionIdStatusGetResponseError = (getSessionStatusApiV1SessionsSessionIdStatusGetResponse404 | getSessionStatusApiV1SessionsSessionIdStatusGetResponse422) & {
  headers: Headers;
};

export type getSessionStatusApiV1SessionsSessionIdStatusGetResponse = (getSessionStatusApiV1SessionsSessionIdStatusGetResponseSuccess | getSessionStatusApiV1SessionsSessionIdStatusGetResponseError)

export const getGetSessionStatusApiV1SessionsSessionIdStatusGetUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}/status`
}

export const getSessionStatusApiV1SessionsSessionIdStatusGet = async (sessionId: number, options?: RequestInit): Promise<getSessionStatusApiV1SessionsSessionIdStatusGetResponse> => {

  return customFetcher<getSessionStatusApiV1SessionsSessionIdStatusGetResponse>(getGetSessionStatusApiV1SessionsSessionIdStatusGetUrl(sessionId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetSessionStatusApiV1SessionsSessionIdStatusGetQueryKey = (sessionId?: number,) => {
    return [
    `/api/v1/sessions/${sessionId}/status`
    ] as const;
    }


export const getGetSessionStatusApiV1SessionsSessionIdStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError = ErrorResponse | HTTPValidationError>(sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionStatusApiV1SessionsSessionIdStatusGetQueryKey(sessionId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>> = ({ signal }) => getSessionStatusApiV1SessionsSessionIdStatusGet(sessionId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionStatusApiV1SessionsSessionIdStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>>
export type GetSessionStatusApiV1SessionsSessionIdStatusGetQueryError = ErrorResponse | HTTPValidationError


export function useGetSessionStatusApiV1SessionsSessionIdStatusGet<TData = Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionStatusApiV1SessionsSessionIdStatusGet<TData = Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionStatusApiV1SessionsSessionIdStatusGet<TData = Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Session Status
 */

export function useGetSessionStatusApiV1SessionsSessionIdStatusGet<TData = Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionStatusApiV1SessionsSessionIdStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionStatusApiV1SessionsSessionIdStatusGetQueryOptions(sessionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Join a session with a nickname via QR code scan.

- **session_id**: Session ID from QR code URL
- **nickname**: Desired participant nickname (1-50 characters)

Returns participant_id and current session state for synchronization.
 * @summary Join Session
 */
export type joinSessionApiV1SessionsSessionIdJoinPostResponse200 = {
  data: ParticipantJoinResponse
  status: 200
}

export type joinSessionApiV1SessionsSessionIdJoinPostResponse400 = {
  data: ErrorResponse
  status: 400
}

export type joinSessionApiV1SessionsSessionIdJoinPostResponse404 = {
  data: ErrorResponse
  status: 404
}

export type joinSessionApiV1SessionsSessionIdJoinPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type joinSessionApiV1SessionsSessionIdJoinPostResponseSuccess = (joinSessionApiV1SessionsSessionIdJoinPostResponse200) & {
  headers: Headers;
};
export type joinSessionApiV1SessionsSessionIdJoinPostResponseError = (joinSessionApiV1SessionsSessionIdJoinPostResponse400 | joinSessionApiV1SessionsSessionIdJoinPostResponse404 | joinSessionApiV1SessionsSessionIdJoinPostResponse422) & {
  headers: Headers;
};

export type joinSessionApiV1SessionsSessionIdJoinPostResponse = (joinSessionApiV1SessionsSessionIdJoinPostResponseSuccess | joinSessionApiV1SessionsSessionIdJoinPostResponseError)

export const getJoinSessionApiV1SessionsSessionIdJoinPostUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}/join`
}

export const joinSessionApiV1SessionsSessionIdJoinPost = async (sessionId: number,
    participantJoinRequest: ParticipantJoinRequest, options?: RequestInit): Promise<joinSessionApiV1SessionsSessionIdJoinPostResponse> => {

  return customFetcher<joinSessionApiV1SessionsSessionIdJoinPostResponse>(getJoinSessionApiV1SessionsSessionIdJoinPostUrl(sessionId),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      participantJoinRequest,)
  }
);}




export const getJoinSessionApiV1SessionsSessionIdJoinPostMutationOptions = <TError = ErrorResponse | ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinSessionApiV1SessionsSessionIdJoinPost>>, TError,{sessionId: number;data: ParticipantJoinRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof joinSessionApiV1SessionsSessionIdJoinPost>>, TError,{sessionId: number;data: ParticipantJoinRequest}, TContext> => {

const mutationKey = ['joinSessionApiV1SessionsSessionIdJoinPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joinSessionApiV1SessionsSessionIdJoinPost>>, {sessionId: number;data: ParticipantJoinRequest}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  joinSessionApiV1SessionsSessionIdJoinPost(sessionId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type JoinSessionApiV1SessionsSessionIdJoinPostMutationResult = NonNullable<Awaited<ReturnType<typeof joinSessionApiV1SessionsSessionIdJoinPost>>>
    export type JoinSessionApiV1SessionsSessionIdJoinPostMutationBody = ParticipantJoinRequest
    export type JoinSessionApiV1SessionsSessionIdJoinPostMutationError = ErrorResponse | ErrorResponse | HTTPValidationError

    /**
 * @summary Join Session
 */
export const useJoinSessionApiV1SessionsSessionIdJoinPost = <TError = ErrorResponse | ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joinSessionApiV1SessionsSessionIdJoinPost>>, TError,{sessionId: number;data: ParticipantJoinRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof joinSessionApiV1SessionsSessionIdJoinPost>>,
        TError,
        {sessionId: number;data: ParticipantJoinRequest},
        TContext
      > => {

      const mutationOptions = getJoinSessionApiV1SessionsSessionIdJoinPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Validate if a nickname is available in a session.

- **session_id**: Session ID to check nickname availability
- **nickname**: Nickname to validate

Returns availability status and suggested alternatives if taken.
 * @summary Validate Nickname
 */
export type validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponse200 = {
  data: NicknameValidationResponse
  status: 200
}

export type validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponseSuccess = (validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponse200) & {
  headers: Headers;
};
export type validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponseError = (validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponse422) & {
  headers: Headers;
};

export type validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponse = (validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponseSuccess | validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponseError)

export const getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetUrl = (sessionId: number,
    params: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/${sessionId}/nicknames/validate?${stringifiedParams}` : `/api/v1/sessions/${sessionId}/nicknames/validate`
}

export const validateNicknameApiV1SessionsSessionIdNicknamesValidateGet = async (sessionId: number,
    params: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams, options?: RequestInit): Promise<validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponse> => {

  return customFetcher<validateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponse>(getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetUrl(sessionId,params),
  {
    ...options,
    method: 'GET'


  }
);}





export const getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetQueryKey = (sessionId?: number,
    params?: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams,) => {
    return [
    `/api/v1/sessions/${sessionId}/nicknames/validate`, ...(params ? [params]: [])
    ] as const;
    }


export const getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetQueryOptions = <TData = Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError = HTTPValidationError>(sessionId: number,
    params: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetQueryKey(sessionId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>> = ({ signal }) => validateNicknameApiV1SessionsSessionIdNicknamesValidateGet(sessionId,params, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetQueryResult = NonNullable<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>>
export type ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetQueryError = HTTPValidationError


export function useValidateNicknameApiV1SessionsSessionIdNicknamesValidateGet<TData = Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>,
          TError,
          Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateNicknameApiV1SessionsSessionIdNicknamesValidateGet<TData = Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>,
          TError,
          Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidateNicknameApiV1SessionsSessionIdNicknamesValidateGet<TData = Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Validate Nickname
 */

export function useValidateNicknameApiV1SessionsSessionIdNicknamesValidateGet<TData = Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params: ValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateNicknameApiV1SessionsSessionIdNicknamesValidateGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetQueryOptions(sessionId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update participant heartbeat and get current activity context.

- **participant_id**: UUID of participant
- **activity_context**: Optional context data from current activity

Returns computed status and current activity information.
Should be called every 15-30 seconds by participant clients.
 * @summary Update Heartbeat
 */
export type updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse200 = {
  data: ParticipantHeartbeatResponse
  status: 200
}

export type updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponseSuccess = (updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse200) & {
  headers: Headers;
};
export type updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponseError = (updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse404 | updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse422) & {
  headers: Headers;
};

export type updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse = (updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponseSuccess | updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponseError)

export const getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostUrl = (participantId: string,) => {




  return `/api/v1/participants/${participantId}/heartbeat`
}

export const updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost = async (participantId: string,
    participantHeartbeatRequest: ParticipantHeartbeatRequest, options?: RequestInit): Promise<updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse> => {

  return customFetcher<updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponse>(getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostUrl(participantId),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      participantHeartbeatRequest,)
  }
);}




export const getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostMutationOptions = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost>>, TError,{participantId: string;data: ParticipantHeartbeatRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost>>, TError,{participantId: string;data: ParticipantHeartbeatRequest}, TContext> => {

const mutationKey = ['updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost>>, {participantId: string;data: ParticipantHeartbeatRequest}> = (props) => {
          const {participantId,data} = props ?? {};

          return  updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost(participantId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostMutationResult = NonNullable<Awaited<ReturnType<typeof updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost>>>
    export type UpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostMutationBody = ParticipantHeartbeatRequest
    export type UpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostMutationError = ErrorResponse | HTTPValidationError

    /**
 * @summary Update Heartbeat
 */
export const useUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost>>, TError,{participantId: string;data: ParticipantHeartbeatRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPost>>,
        TError,
        {participantId: string;data: ParticipantHeartbeatRequest},
        TContext
      > => {

      const mutationOptions = getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get all participants in a session with their computed status.

- **session_id**: Session ID to get participants for

Returns list of participants with online/idle/disconnected status
computed from their last heartbeat timing.
 * @summary Get Session Participants
 */
export type getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse200 = {
  data: ParticipantListResponse
  status: 200
}

export type getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponseSuccess = (getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse200) & {
  headers: Headers;
};
export type getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponseError = (getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse404 | getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse422) & {
  headers: Headers;
};

export type getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse = (getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponseSuccess | getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponseError)

export const getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}/participants`
}

export const getSessionParticipantsApiV1SessionsSessionIdParticipantsGet = async (sessionId: number, options?: RequestInit): Promise<getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse> => {

  return customFetcher<getSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponse>(getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetUrl(sessionId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetQueryKey = (sessionId?: number,) => {
    return [
    `/api/v1/sessions/${sessionId}/participants`
    ] as const;
    }


export const getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetQueryOptions = <TData = Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError = ErrorResponse | HTTPValidationError>(sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetQueryKey(sessionId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>> = ({ signal }) => getSessionParticipantsApiV1SessionsSessionIdParticipantsGet(sessionId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionParticipantsApiV1SessionsSessionIdParticipantsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>>
export type GetSessionParticipantsApiV1SessionsSessionIdParticipantsGetQueryError = ErrorResponse | HTTPValidationError


export function useGetSessionParticipantsApiV1SessionsSessionIdParticipantsGet<TData = Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionParticipantsApiV1SessionsSessionIdParticipantsGet<TData = Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionParticipantsApiV1SessionsSessionIdParticipantsGet<TData = Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Session Participants
 */

export function useGetSessionParticipantsApiV1SessionsSessionIdParticipantsGet<TData = Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError = ErrorResponse | HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionParticipantsApiV1SessionsSessionIdParticipantsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetQueryOptions(sessionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Remove a participant from their session.

- **participant_id**: UUID of participant to remove

Admin operation to kick participants or clean up disconnected users.
 * @summary Remove Participant
 */
export type removeParticipantApiV1ParticipantsParticipantIdDeleteResponse200 = {
  data: unknown
  status: 200
}

export type removeParticipantApiV1ParticipantsParticipantIdDeleteResponse204 = {
  data: void
  status: 204
}

export type removeParticipantApiV1ParticipantsParticipantIdDeleteResponse404 = {
  data: ErrorResponse
  status: 404
}

export type removeParticipantApiV1ParticipantsParticipantIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type removeParticipantApiV1ParticipantsParticipantIdDeleteResponseSuccess = (removeParticipantApiV1ParticipantsParticipantIdDeleteResponse200 | removeParticipantApiV1ParticipantsParticipantIdDeleteResponse204) & {
  headers: Headers;
};
export type removeParticipantApiV1ParticipantsParticipantIdDeleteResponseError = (removeParticipantApiV1ParticipantsParticipantIdDeleteResponse404 | removeParticipantApiV1ParticipantsParticipantIdDeleteResponse422) & {
  headers: Headers;
};

export type removeParticipantApiV1ParticipantsParticipantIdDeleteResponse = (removeParticipantApiV1ParticipantsParticipantIdDeleteResponseSuccess | removeParticipantApiV1ParticipantsParticipantIdDeleteResponseError)

export const getRemoveParticipantApiV1ParticipantsParticipantIdDeleteUrl = (participantId: string,) => {




  return `/api/v1/participants/${participantId}`
}

export const removeParticipantApiV1ParticipantsParticipantIdDelete = async (participantId: string, options?: RequestInit): Promise<removeParticipantApiV1ParticipantsParticipantIdDeleteResponse> => {

  return customFetcher<removeParticipantApiV1ParticipantsParticipantIdDeleteResponse>(getRemoveParticipantApiV1ParticipantsParticipantIdDeleteUrl(participantId),
  {
    ...options,
    method: 'DELETE'


  }
);}




export const getRemoveParticipantApiV1ParticipantsParticipantIdDeleteMutationOptions = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeParticipantApiV1ParticipantsParticipantIdDelete>>, TError,{participantId: string}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof removeParticipantApiV1ParticipantsParticipantIdDelete>>, TError,{participantId: string}, TContext> => {

const mutationKey = ['removeParticipantApiV1ParticipantsParticipantIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeParticipantApiV1ParticipantsParticipantIdDelete>>, {participantId: string}> = (props) => {
          const {participantId} = props ?? {};

          return  removeParticipantApiV1ParticipantsParticipantIdDelete(participantId,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type RemoveParticipantApiV1ParticipantsParticipantIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof removeParticipantApiV1ParticipantsParticipantIdDelete>>>

    export type RemoveParticipantApiV1ParticipantsParticipantIdDeleteMutationError = ErrorResponse | HTTPValidationError

    /**
 * @summary Remove Participant
 */
export const useRemoveParticipantApiV1ParticipantsParticipantIdDelete = <TError = ErrorResponse | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeParticipantApiV1ParticipantsParticipantIdDelete>>, TError,{participantId: string}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeParticipantApiV1ParticipantsParticipantIdDelete>>,
        TError,
        {participantId: string},
        TContext
      > => {

      const mutationOptions = getRemoveParticipantApiV1ParticipantsParticipantIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Create a new user response for an activity.
 * @summary Create Response
 */
export type createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponse201 = {
  data: UserResponse
  status: 201
}

export type createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponseSuccess = (createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponse201) & {
  headers: Headers;
};
export type createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponseError = (createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponse422) & {
  headers: Headers;
};

export type createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponse = (createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponseSuccess | createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponseError)

export const getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostUrl = (sessionId: number,
    activityId: string,
    params: CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/${sessionId}/activities/${activityId}/responses?${stringifiedParams}` : `/api/v1/sessions/${sessionId}/activities/${activityId}/responses`
}

export const createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost = async (sessionId: number,
    activityId: string,
    userResponseCreate: UserResponseCreate,
    params: CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams, options?: RequestInit): Promise<createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponse> => {

  return customFetcher<createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponse>(getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostUrl(sessionId,activityId,params),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userResponseCreate,)
  }
);}




export const getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost>>, TError,{sessionId: number;activityId: string;data: UserResponseCreate;params: CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost>>, TError,{sessionId: number;activityId: string;data: UserResponseCreate;params: CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams}, TContext> => {

const mutationKey = ['createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost>>, {sessionId: number;activityId: string;data: UserResponseCreate;params: CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams}> = (props) => {
          const {sessionId,activityId,data,params} = props ?? {};

          return  createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost(sessionId,activityId,data,params,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost>>>
    export type CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostMutationBody = UserResponseCreate
    export type CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostMutationError = HTTPValidationError

    /**
 * @summary Create Response
 */
export const useCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost>>, TError,{sessionId: number;activityId: string;data: UserResponseCreate;params: CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPost>>,
        TError,
        {sessionId: number;activityId: string;data: UserResponseCreate;params: CreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostParams},
        TContext
      > => {

      const mutationOptions = getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get all responses for a specific activity with summary.
 * @summary Get Activity Responses
 */
export type getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponse200 = {
  data: UserResponseList
  status: 200
}

export type getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponseSuccess = (getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponse200) & {
  headers: Headers;
};
export type getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponseError = (getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponse422) & {
  headers: Headers;
};

export type getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponse = (getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponseSuccess | getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponseError)

export const getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetUrl = (sessionId: number,
    activityId: string,
    params?: GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/${sessionId}/activities/${activityId}/responses?${stringifiedParams}` : `/api/v1/sessions/${sessionId}/activities/${activityId}/responses`
}

export const getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet = async (sessionId: number,
    activityId: string,
    params?: GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams, options?: RequestInit): Promise<getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponse> => {

  return customFetcher<getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponse>(getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetUrl(sessionId,activityId,params),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetQueryKey = (sessionId?: number,
    activityId?: string,
    params?: GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams,) => {
    return [
    `/api/v1/sessions/${sessionId}/activities/${activityId}/responses`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetQueryOptions = <TData = Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError = HTTPValidationError>(sessionId: number,
    activityId: string,
    params?: GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetQueryKey(sessionId,activityId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>> = ({ signal }) => getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet(sessionId,activityId,params, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId && activityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>>
export type GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetQueryError = HTTPValidationError


export function useGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet<TData = Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    params: undefined |  GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet<TData = Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    params?: GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet<TData = Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    params?: GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Activity Responses
 */

export function useGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet<TData = Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    params?: GetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetQueryOptions(sessionId,activityId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific participant's response for an activity.
 * @summary Get Participant Response
 */
export type getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponse200 = {
  data: GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet200
  status: 200
}

export type getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponseSuccess = (getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponse200) & {
  headers: Headers;
};
export type getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponseError = (getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponse422) & {
  headers: Headers;
};

export type getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponse = (getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponseSuccess | getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponseError)

export const getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetUrl = (sessionId: number,
    activityId: string,
    participantId: number,) => {




  return `/api/v1/sessions/${sessionId}/activities/${activityId}/responses/${participantId}`
}

export const getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet = async (sessionId: number,
    activityId: string,
    participantId: number, options?: RequestInit): Promise<getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponse> => {

  return customFetcher<getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponse>(getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetUrl(sessionId,activityId,participantId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetQueryKey = (sessionId?: number,
    activityId?: string,
    participantId?: number,) => {
    return [
    `/api/v1/sessions/${sessionId}/activities/${activityId}/responses/${participantId}`
    ] as const;
    }


export const getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError = HTTPValidationError>(sessionId: number,
    activityId: string,
    participantId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetQueryKey(sessionId,activityId,participantId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>> = ({ signal }) => getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet(sessionId,activityId,participantId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId && activityId && participantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>>
export type GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetQueryError = HTTPValidationError


export function useGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet<TData = Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    participantId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>,
          TError,
          Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet<TData = Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    participantId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>,
          TError,
          Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet<TData = Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    participantId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Participant Response
 */

export function useGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet<TData = Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    participantId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetQueryOptions(sessionId,activityId,participantId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing user response.
 * @summary Update Response
 */
export type updateResponseApiV1ResponsesResponseIdPutResponse200 = {
  data: UserResponse
  status: 200
}

export type updateResponseApiV1ResponsesResponseIdPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateResponseApiV1ResponsesResponseIdPutResponseSuccess = (updateResponseApiV1ResponsesResponseIdPutResponse200) & {
  headers: Headers;
};
export type updateResponseApiV1ResponsesResponseIdPutResponseError = (updateResponseApiV1ResponsesResponseIdPutResponse422) & {
  headers: Headers;
};

export type updateResponseApiV1ResponsesResponseIdPutResponse = (updateResponseApiV1ResponsesResponseIdPutResponseSuccess | updateResponseApiV1ResponsesResponseIdPutResponseError)

export const getUpdateResponseApiV1ResponsesResponseIdPutUrl = (responseId: string,) => {




  return `/api/v1/responses/${responseId}`
}

export const updateResponseApiV1ResponsesResponseIdPut = async (responseId: string,
    userResponseUpdate: UserResponseUpdate, options?: RequestInit): Promise<updateResponseApiV1ResponsesResponseIdPutResponse> => {

  return customFetcher<updateResponseApiV1ResponsesResponseIdPutResponse>(getUpdateResponseApiV1ResponsesResponseIdPutUrl(responseId),
  {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userResponseUpdate,)
  }
);}




export const getUpdateResponseApiV1ResponsesResponseIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResponseApiV1ResponsesResponseIdPut>>, TError,{responseId: string;data: UserResponseUpdate}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateResponseApiV1ResponsesResponseIdPut>>, TError,{responseId: string;data: UserResponseUpdate}, TContext> => {

const mutationKey = ['updateResponseApiV1ResponsesResponseIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateResponseApiV1ResponsesResponseIdPut>>, {responseId: string;data: UserResponseUpdate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  updateResponseApiV1ResponsesResponseIdPut(responseId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateResponseApiV1ResponsesResponseIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateResponseApiV1ResponsesResponseIdPut>>>
    export type UpdateResponseApiV1ResponsesResponseIdPutMutationBody = UserResponseUpdate
    export type UpdateResponseApiV1ResponsesResponseIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Response
 */
export const useUpdateResponseApiV1ResponsesResponseIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResponseApiV1ResponsesResponseIdPut>>, TError,{responseId: string;data: UserResponseUpdate}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateResponseApiV1ResponsesResponseIdPut>>,
        TError,
        {responseId: string;data: UserResponseUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateResponseApiV1ResponsesResponseIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Delete a user response.
 * @summary Delete Response
 */
export type deleteResponseApiV1ResponsesResponseIdDeleteResponse204 = {
  data: void
  status: 204
}

export type deleteResponseApiV1ResponsesResponseIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteResponseApiV1ResponsesResponseIdDeleteResponseSuccess = (deleteResponseApiV1ResponsesResponseIdDeleteResponse204) & {
  headers: Headers;
};
export type deleteResponseApiV1ResponsesResponseIdDeleteResponseError = (deleteResponseApiV1ResponsesResponseIdDeleteResponse422) & {
  headers: Headers;
};

export type deleteResponseApiV1ResponsesResponseIdDeleteResponse = (deleteResponseApiV1ResponsesResponseIdDeleteResponseSuccess | deleteResponseApiV1ResponsesResponseIdDeleteResponseError)

export const getDeleteResponseApiV1ResponsesResponseIdDeleteUrl = (responseId: string,) => {




  return `/api/v1/responses/${responseId}`
}

export const deleteResponseApiV1ResponsesResponseIdDelete = async (responseId: string, options?: RequestInit): Promise<deleteResponseApiV1ResponsesResponseIdDeleteResponse> => {

  return customFetcher<deleteResponseApiV1ResponsesResponseIdDeleteResponse>(getDeleteResponseApiV1ResponsesResponseIdDeleteUrl(responseId),
  {
    ...options,
    method: 'DELETE'


  }
);}




export const getDeleteResponseApiV1ResponsesResponseIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResponseApiV1ResponsesResponseIdDelete>>, TError,{responseId: string}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteResponseApiV1ResponsesResponseIdDelete>>, TError,{responseId: string}, TContext> => {

const mutationKey = ['deleteResponseApiV1ResponsesResponseIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteResponseApiV1ResponsesResponseIdDelete>>, {responseId: string}> = (props) => {
          const {responseId} = props ?? {};

          return  deleteResponseApiV1ResponsesResponseIdDelete(responseId,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteResponseApiV1ResponsesResponseIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteResponseApiV1ResponsesResponseIdDelete>>>

    export type DeleteResponseApiV1ResponsesResponseIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Response
 */
export const useDeleteResponseApiV1ResponsesResponseIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResponseApiV1ResponsesResponseIdDelete>>, TError,{responseId: string}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteResponseApiV1ResponsesResponseIdDelete>>,
        TError,
        {responseId: string},
        TContext
      > => {

      const mutationOptions = getDeleteResponseApiV1ResponsesResponseIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get all responses by a specific participant in a session.
 * @summary Get Participant Responses
 */
export type getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponse200 = {
  data: UserResponse[]
  status: 200
}

export type getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponseSuccess = (getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponse200) & {
  headers: Headers;
};
export type getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponseError = (getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponse422) & {
  headers: Headers;
};

export type getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponse = (getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponseSuccess | getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponseError)

export const getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetUrl = (sessionId: number,
    participantId: number,
    params?: GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/${sessionId}/participants/${participantId}/responses?${stringifiedParams}` : `/api/v1/sessions/${sessionId}/participants/${participantId}/responses`
}

export const getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet = async (sessionId: number,
    participantId: number,
    params?: GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams, options?: RequestInit): Promise<getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponse> => {

  return customFetcher<getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponse>(getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetUrl(sessionId,participantId,params),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetQueryKey = (sessionId?: number,
    participantId?: number,
    params?: GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams,) => {
    return [
    `/api/v1/sessions/${sessionId}/participants/${participantId}/responses`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetQueryOptions = <TData = Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError = HTTPValidationError>(sessionId: number,
    participantId: number,
    params?: GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetQueryKey(sessionId,participantId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>> = ({ signal }) => getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet(sessionId,participantId,params, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId && participantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>>
export type GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetQueryError = HTTPValidationError


export function useGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet<TData = Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    participantId: number,
    params: undefined |  GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>,
          TError,
          Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet<TData = Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    participantId: number,
    params?: GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>,
          TError,
          Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet<TData = Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    participantId: number,
    params?: GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Participant Responses
 */

export function useGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet<TData = Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    participantId: number,
    params?: GetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetQueryOptions(sessionId,participantId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get responses created since a specific timestamp for incremental updates.
 * @summary Get Responses Since
 */
export type getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponse200 = {
  data: IncrementalResponseList
  status: 200
}

export type getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponseSuccess = (getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponse200) & {
  headers: Headers;
};
export type getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponseError = (getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponse422) & {
  headers: Headers;
};

export type getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponse = (getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponseSuccess | getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponseError)

export const getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetUrl = (sessionId: number,
    activityId: string,
    timestamp: string,
    params?: GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/${sessionId}/activities/${activityId}/responses/since/${timestamp}?${stringifiedParams}` : `/api/v1/sessions/${sessionId}/activities/${activityId}/responses/since/${timestamp}`
}

export const getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet = async (sessionId: number,
    activityId: string,
    timestamp: string,
    params?: GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams, options?: RequestInit): Promise<getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponse> => {

  return customFetcher<getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponse>(getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetUrl(sessionId,activityId,timestamp,params),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetQueryKey = (sessionId?: number,
    activityId?: string,
    timestamp?: string,
    params?: GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams,) => {
    return [
    `/api/v1/sessions/${sessionId}/activities/${activityId}/responses/since/${timestamp}`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetQueryOptions = <TData = Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError = HTTPValidationError>(sessionId: number,
    activityId: string,
    timestamp: string,
    params?: GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetQueryKey(sessionId,activityId,timestamp,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>> = ({ signal }) => getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet(sessionId,activityId,timestamp,params, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId && activityId && timestamp), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetQueryResult = NonNullable<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>>
export type GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetQueryError = HTTPValidationError


export function useGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet<TData = Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    timestamp: string,
    params: undefined |  GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>,
          TError,
          Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet<TData = Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    timestamp: string,
    params?: GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>,
          TError,
          Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet<TData = Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    timestamp: string,
    params?: GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Responses Since
 */

export function useGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet<TData = Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string,
    timestamp: string,
    params?: GetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetQueryOptions(sessionId,activityId,timestamp,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new activity for a session.
 * @summary Create Activity
 */
export type createActivityApiV1SessionsSessionIdActivitiesPostResponse201 = {
  data: Activity
  status: 201
}

export type createActivityApiV1SessionsSessionIdActivitiesPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createActivityApiV1SessionsSessionIdActivitiesPostResponseSuccess = (createActivityApiV1SessionsSessionIdActivitiesPostResponse201) & {
  headers: Headers;
};
export type createActivityApiV1SessionsSessionIdActivitiesPostResponseError = (createActivityApiV1SessionsSessionIdActivitiesPostResponse422) & {
  headers: Headers;
};

export type createActivityApiV1SessionsSessionIdActivitiesPostResponse = (createActivityApiV1SessionsSessionIdActivitiesPostResponseSuccess | createActivityApiV1SessionsSessionIdActivitiesPostResponseError)

export const getCreateActivityApiV1SessionsSessionIdActivitiesPostUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}/activities`
}

export const createActivityApiV1SessionsSessionIdActivitiesPost = async (sessionId: number,
    activityCreate: ActivityCreate, options?: RequestInit): Promise<createActivityApiV1SessionsSessionIdActivitiesPostResponse> => {

  return customFetcher<createActivityApiV1SessionsSessionIdActivitiesPostResponse>(getCreateActivityApiV1SessionsSessionIdActivitiesPostUrl(sessionId),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      activityCreate,)
  }
);}




export const getCreateActivityApiV1SessionsSessionIdActivitiesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createActivityApiV1SessionsSessionIdActivitiesPost>>, TError,{sessionId: number;data: ActivityCreate}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createActivityApiV1SessionsSessionIdActivitiesPost>>, TError,{sessionId: number;data: ActivityCreate}, TContext> => {

const mutationKey = ['createActivityApiV1SessionsSessionIdActivitiesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createActivityApiV1SessionsSessionIdActivitiesPost>>, {sessionId: number;data: ActivityCreate}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  createActivityApiV1SessionsSessionIdActivitiesPost(sessionId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateActivityApiV1SessionsSessionIdActivitiesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createActivityApiV1SessionsSessionIdActivitiesPost>>>
    export type CreateActivityApiV1SessionsSessionIdActivitiesPostMutationBody = ActivityCreate
    export type CreateActivityApiV1SessionsSessionIdActivitiesPostMutationError = HTTPValidationError

    /**
 * @summary Create Activity
 */
export const useCreateActivityApiV1SessionsSessionIdActivitiesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createActivityApiV1SessionsSessionIdActivitiesPost>>, TError,{sessionId: number;data: ActivityCreate}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createActivityApiV1SessionsSessionIdActivitiesPost>>,
        TError,
        {sessionId: number;data: ActivityCreate},
        TContext
      > => {

      const mutationOptions = getCreateActivityApiV1SessionsSessionIdActivitiesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get all activities for a session.
 * @summary Get Session Activities
 */
export type getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponse200 = {
  data: ActivityList
  status: 200
}

export type getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponseSuccess = (getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponse200) & {
  headers: Headers;
};
export type getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponseError = (getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponse422) & {
  headers: Headers;
};

export type getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponse = (getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponseSuccess | getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponseError)

export const getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetUrl = (sessionId: number,
    params?: GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/sessions/${sessionId}/activities?${stringifiedParams}` : `/api/v1/sessions/${sessionId}/activities`
}

export const getSessionActivitiesApiV1SessionsSessionIdActivitiesGet = async (sessionId: number,
    params?: GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams, options?: RequestInit): Promise<getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponse> => {

  return customFetcher<getSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponse>(getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetUrl(sessionId,params),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetQueryKey = (sessionId?: number,
    params?: GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams,) => {
    return [
    `/api/v1/sessions/${sessionId}/activities`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetQueryOptions = <TData = Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError = HTTPValidationError>(sessionId: number,
    params?: GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetQueryKey(sessionId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>> = ({ signal }) => getSessionActivitiesApiV1SessionsSessionIdActivitiesGet(sessionId,params, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>>
export type GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetQueryError = HTTPValidationError


export function useGetSessionActivitiesApiV1SessionsSessionIdActivitiesGet<TData = Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params: undefined |  GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionActivitiesApiV1SessionsSessionIdActivitiesGet<TData = Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params?: GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>,
          TError,
          Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionActivitiesApiV1SessionsSessionIdActivitiesGet<TData = Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params?: GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Session Activities
 */

export function useGetSessionActivitiesApiV1SessionsSessionIdActivitiesGet<TData = Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError = HTTPValidationError>(
 sessionId: number,
    params?: GetSessionActivitiesApiV1SessionsSessionIdActivitiesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionActivitiesApiV1SessionsSessionIdActivitiesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetQueryOptions(sessionId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all available activity types from the framework.
 * @summary Get Activity Types
 */
export type getActivityTypesApiV1ActivitiesTypesGetResponse200 = {
  data: ActivityTypesListResponse
  status: 200
}

export type getActivityTypesApiV1ActivitiesTypesGetResponseSuccess = (getActivityTypesApiV1ActivitiesTypesGetResponse200) & {
  headers: Headers;
};
;

export type getActivityTypesApiV1ActivitiesTypesGetResponse = (getActivityTypesApiV1ActivitiesTypesGetResponseSuccess)

export const getGetActivityTypesApiV1ActivitiesTypesGetUrl = () => {




  return `/api/v1/activities/types`
}

export const getActivityTypesApiV1ActivitiesTypesGet = async ( options?: RequestInit): Promise<getActivityTypesApiV1ActivitiesTypesGetResponse> => {

  return customFetcher<getActivityTypesApiV1ActivitiesTypesGetResponse>(getGetActivityTypesApiV1ActivitiesTypesGetUrl(),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetActivityTypesApiV1ActivitiesTypesGetQueryKey = () => {
    return [
    `/api/v1/activities/types`
    ] as const;
    }


export const getGetActivityTypesApiV1ActivitiesTypesGetQueryOptions = <TData = Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityTypesApiV1ActivitiesTypesGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>> = ({ signal }) => getActivityTypesApiV1ActivitiesTypesGet({ signal, ...requestOptions });





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActivityTypesApiV1ActivitiesTypesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>>
export type GetActivityTypesApiV1ActivitiesTypesGetQueryError = unknown


export function useGetActivityTypesApiV1ActivitiesTypesGet<TData = Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityTypesApiV1ActivitiesTypesGet<TData = Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityTypesApiV1ActivitiesTypesGet<TData = Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Activity Types
 */

export function useGetActivityTypesApiV1ActivitiesTypesGet<TData = Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypesApiV1ActivitiesTypesGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActivityTypesApiV1ActivitiesTypesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get JSON schema for a specific activity type.
 * @summary Get Activity Type Schema
 */
export type getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponse200 = {
  data: ActivityTypeSchemaResponse
  status: 200
}

export type getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponseSuccess = (getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponse200) & {
  headers: Headers;
};
export type getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponseError = (getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponse422) & {
  headers: Headers;
};

export type getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponse = (getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponseSuccess | getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponseError)

export const getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetUrl = (activityType: string,) => {




  return `/api/v1/activities/types/${activityType}/schema`
}

export const getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet = async (activityType: string, options?: RequestInit): Promise<getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponse> => {

  return customFetcher<getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponse>(getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetUrl(activityType),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetQueryKey = (activityType?: string,) => {
    return [
    `/api/v1/activities/types/${activityType}/schema`
    ] as const;
    }


export const getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetQueryOptions = <TData = Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError = HTTPValidationError>(activityType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetQueryKey(activityType);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>> = ({ signal }) => getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet(activityType, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(activityType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>>
export type GetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetQueryError = HTTPValidationError


export function useGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet<TData = Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError = HTTPValidationError>(
 activityType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet<TData = Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError = HTTPValidationError>(
 activityType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet<TData = Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError = HTTPValidationError>(
 activityType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Activity Type Schema
 */

export function useGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet<TData = Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError = HTTPValidationError>(
 activityType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetQueryOptions(activityType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Validate activity configuration against type schema.
 * @summary Validate Activity Configuration
 */
export type validateActivityConfigurationApiV1ActivitiesValidatePostResponse200 = {
  data: ActivityValidationResponse
  status: 200
}

export type validateActivityConfigurationApiV1ActivitiesValidatePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type validateActivityConfigurationApiV1ActivitiesValidatePostResponseSuccess = (validateActivityConfigurationApiV1ActivitiesValidatePostResponse200) & {
  headers: Headers;
};
export type validateActivityConfigurationApiV1ActivitiesValidatePostResponseError = (validateActivityConfigurationApiV1ActivitiesValidatePostResponse422) & {
  headers: Headers;
};

export type validateActivityConfigurationApiV1ActivitiesValidatePostResponse = (validateActivityConfigurationApiV1ActivitiesValidatePostResponseSuccess | validateActivityConfigurationApiV1ActivitiesValidatePostResponseError)

export const getValidateActivityConfigurationApiV1ActivitiesValidatePostUrl = () => {




  return `/api/v1/activities/validate`
}

export const validateActivityConfigurationApiV1ActivitiesValidatePost = async (activityValidationRequest: ActivityValidationRequest, options?: RequestInit): Promise<validateActivityConfigurationApiV1ActivitiesValidatePostResponse> => {

  return customFetcher<validateActivityConfigurationApiV1ActivitiesValidatePostResponse>(getValidateActivityConfigurationApiV1ActivitiesValidatePostUrl(),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      activityValidationRequest,)
  }
);}




export const getValidateActivityConfigurationApiV1ActivitiesValidatePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateActivityConfigurationApiV1ActivitiesValidatePost>>, TError,{data: ActivityValidationRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof validateActivityConfigurationApiV1ActivitiesValidatePost>>, TError,{data: ActivityValidationRequest}, TContext> => {

const mutationKey = ['validateActivityConfigurationApiV1ActivitiesValidatePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateActivityConfigurationApiV1ActivitiesValidatePost>>, {data: ActivityValidationRequest}> = (props) => {
          const {data} = props ?? {};

          return  validateActivityConfigurationApiV1ActivitiesValidatePost(data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type ValidateActivityConfigurationApiV1ActivitiesValidatePostMutationResult = NonNullable<Awaited<ReturnType<typeof validateActivityConfigurationApiV1ActivitiesValidatePost>>>
    export type ValidateActivityConfigurationApiV1ActivitiesValidatePostMutationBody = ActivityValidationRequest
    export type ValidateActivityConfigurationApiV1ActivitiesValidatePostMutationError = HTTPValidationError

    /**
 * @summary Validate Activity Configuration
 */
export const useValidateActivityConfigurationApiV1ActivitiesValidatePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateActivityConfigurationApiV1ActivitiesValidatePost>>, TError,{data: ActivityValidationRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateActivityConfigurationApiV1ActivitiesValidatePost>>,
        TError,
        {data: ActivityValidationRequest},
        TContext
      > => {

      const mutationOptions = getValidateActivityConfigurationApiV1ActivitiesValidatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get an activity by ID.
 * @summary Get Activity
 */
export type getActivityApiV1ActivitiesActivityIdGetResponse200 = {
  data: Activity
  status: 200
}

export type getActivityApiV1ActivitiesActivityIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getActivityApiV1ActivitiesActivityIdGetResponseSuccess = (getActivityApiV1ActivitiesActivityIdGetResponse200) & {
  headers: Headers;
};
export type getActivityApiV1ActivitiesActivityIdGetResponseError = (getActivityApiV1ActivitiesActivityIdGetResponse422) & {
  headers: Headers;
};

export type getActivityApiV1ActivitiesActivityIdGetResponse = (getActivityApiV1ActivitiesActivityIdGetResponseSuccess | getActivityApiV1ActivitiesActivityIdGetResponseError)

export const getGetActivityApiV1ActivitiesActivityIdGetUrl = (activityId: string,) => {




  return `/api/v1/activities/${activityId}`
}

export const getActivityApiV1ActivitiesActivityIdGet = async (activityId: string, options?: RequestInit): Promise<getActivityApiV1ActivitiesActivityIdGetResponse> => {

  return customFetcher<getActivityApiV1ActivitiesActivityIdGetResponse>(getGetActivityApiV1ActivitiesActivityIdGetUrl(activityId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetActivityApiV1ActivitiesActivityIdGetQueryKey = (activityId?: string,) => {
    return [
    `/api/v1/activities/${activityId}`
    ] as const;
    }


export const getGetActivityApiV1ActivitiesActivityIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError = HTTPValidationError>(activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityApiV1ActivitiesActivityIdGetQueryKey(activityId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>> = ({ signal }) => getActivityApiV1ActivitiesActivityIdGet(activityId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(activityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActivityApiV1ActivitiesActivityIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>>
export type GetActivityApiV1ActivitiesActivityIdGetQueryError = HTTPValidationError


export function useGetActivityApiV1ActivitiesActivityIdGet<TData = Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError = HTTPValidationError>(
 activityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityApiV1ActivitiesActivityIdGet<TData = Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityApiV1ActivitiesActivityIdGet<TData = Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Activity
 */

export function useGetActivityApiV1ActivitiesActivityIdGet<TData = Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityApiV1ActivitiesActivityIdGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActivityApiV1ActivitiesActivityIdGetQueryOptions(activityId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing activity.
 * @summary Update Activity
 */
export type updateActivityApiV1ActivitiesActivityIdPutResponse200 = {
  data: Activity
  status: 200
}

export type updateActivityApiV1ActivitiesActivityIdPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateActivityApiV1ActivitiesActivityIdPutResponseSuccess = (updateActivityApiV1ActivitiesActivityIdPutResponse200) & {
  headers: Headers;
};
export type updateActivityApiV1ActivitiesActivityIdPutResponseError = (updateActivityApiV1ActivitiesActivityIdPutResponse422) & {
  headers: Headers;
};

export type updateActivityApiV1ActivitiesActivityIdPutResponse = (updateActivityApiV1ActivitiesActivityIdPutResponseSuccess | updateActivityApiV1ActivitiesActivityIdPutResponseError)

export const getUpdateActivityApiV1ActivitiesActivityIdPutUrl = (activityId: string,) => {




  return `/api/v1/activities/${activityId}`
}

export const updateActivityApiV1ActivitiesActivityIdPut = async (activityId: string,
    activityUpdate: ActivityUpdate, options?: RequestInit): Promise<updateActivityApiV1ActivitiesActivityIdPutResponse> => {

  return customFetcher<updateActivityApiV1ActivitiesActivityIdPutResponse>(getUpdateActivityApiV1ActivitiesActivityIdPutUrl(activityId),
  {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      activityUpdate,)
  }
);}




export const getUpdateActivityApiV1ActivitiesActivityIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActivityApiV1ActivitiesActivityIdPut>>, TError,{activityId: string;data: ActivityUpdate}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateActivityApiV1ActivitiesActivityIdPut>>, TError,{activityId: string;data: ActivityUpdate}, TContext> => {

const mutationKey = ['updateActivityApiV1ActivitiesActivityIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateActivityApiV1ActivitiesActivityIdPut>>, {activityId: string;data: ActivityUpdate}> = (props) => {
          const {activityId,data} = props ?? {};

          return  updateActivityApiV1ActivitiesActivityIdPut(activityId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateActivityApiV1ActivitiesActivityIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateActivityApiV1ActivitiesActivityIdPut>>>
    export type UpdateActivityApiV1ActivitiesActivityIdPutMutationBody = ActivityUpdate
    export type UpdateActivityApiV1ActivitiesActivityIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Activity
 */
export const useUpdateActivityApiV1ActivitiesActivityIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActivityApiV1ActivitiesActivityIdPut>>, TError,{activityId: string;data: ActivityUpdate}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateActivityApiV1ActivitiesActivityIdPut>>,
        TError,
        {activityId: string;data: ActivityUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateActivityApiV1ActivitiesActivityIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Delete an activity.
 * @summary Delete Activity
 */
export type deleteActivityApiV1ActivitiesActivityIdDeleteResponse204 = {
  data: void
  status: 204
}

export type deleteActivityApiV1ActivitiesActivityIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteActivityApiV1ActivitiesActivityIdDeleteResponseSuccess = (deleteActivityApiV1ActivitiesActivityIdDeleteResponse204) & {
  headers: Headers;
};
export type deleteActivityApiV1ActivitiesActivityIdDeleteResponseError = (deleteActivityApiV1ActivitiesActivityIdDeleteResponse422) & {
  headers: Headers;
};

export type deleteActivityApiV1ActivitiesActivityIdDeleteResponse = (deleteActivityApiV1ActivitiesActivityIdDeleteResponseSuccess | deleteActivityApiV1ActivitiesActivityIdDeleteResponseError)

export const getDeleteActivityApiV1ActivitiesActivityIdDeleteUrl = (activityId: string,) => {




  return `/api/v1/activities/${activityId}`
}

export const deleteActivityApiV1ActivitiesActivityIdDelete = async (activityId: string, options?: RequestInit): Promise<deleteActivityApiV1ActivitiesActivityIdDeleteResponse> => {

  return customFetcher<deleteActivityApiV1ActivitiesActivityIdDeleteResponse>(getDeleteActivityApiV1ActivitiesActivityIdDeleteUrl(activityId),
  {
    ...options,
    method: 'DELETE'


  }
);}




export const getDeleteActivityApiV1ActivitiesActivityIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteActivityApiV1ActivitiesActivityIdDelete>>, TError,{activityId: string}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteActivityApiV1ActivitiesActivityIdDelete>>, TError,{activityId: string}, TContext> => {

const mutationKey = ['deleteActivityApiV1ActivitiesActivityIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteActivityApiV1ActivitiesActivityIdDelete>>, {activityId: string}> = (props) => {
          const {activityId} = props ?? {};

          return  deleteActivityApiV1ActivitiesActivityIdDelete(activityId,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteActivityApiV1ActivitiesActivityIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteActivityApiV1ActivitiesActivityIdDelete>>>

    export type DeleteActivityApiV1ActivitiesActivityIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Activity
 */
export const useDeleteActivityApiV1ActivitiesActivityIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteActivityApiV1ActivitiesActivityIdDelete>>, TError,{activityId: string}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteActivityApiV1ActivitiesActivityIdDelete>>,
        TError,
        {activityId: string},
        TContext
      > => {

      const mutationOptions = getDeleteActivityApiV1ActivitiesActivityIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Update activity status.
 * @summary Update Activity Status
 */
export type updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponse200 = {
  data: Activity
  status: 200
}

export type updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponseSuccess = (updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponse200) & {
  headers: Headers;
};
export type updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponseError = (updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponse422) & {
  headers: Headers;
};

export type updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponse = (updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponseSuccess | updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponseError)

export const getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchUrl = (activityId: string,
    params: UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/activities/${activityId}/status?${stringifiedParams}` : `/api/v1/activities/${activityId}/status`
}

export const updateActivityStatusApiV1ActivitiesActivityIdStatusPatch = async (activityId: string,
    params: UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams, options?: RequestInit): Promise<updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponse> => {

  return customFetcher<updateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponse>(getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchUrl(activityId,params),
  {
    ...options,
    method: 'PATCH'


  }
);}




export const getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActivityStatusApiV1ActivitiesActivityIdStatusPatch>>, TError,{activityId: string;params: UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateActivityStatusApiV1ActivitiesActivityIdStatusPatch>>, TError,{activityId: string;params: UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams}, TContext> => {

const mutationKey = ['updateActivityStatusApiV1ActivitiesActivityIdStatusPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateActivityStatusApiV1ActivitiesActivityIdStatusPatch>>, {activityId: string;params: UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams}> = (props) => {
          const {activityId,params} = props ?? {};

          return  updateActivityStatusApiV1ActivitiesActivityIdStatusPatch(activityId,params,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateActivityStatusApiV1ActivitiesActivityIdStatusPatch>>>

    export type UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchMutationError = HTTPValidationError

    /**
 * @summary Update Activity Status
 */
export const useUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActivityStatusApiV1ActivitiesActivityIdStatusPatch>>, TError,{activityId: string;params: UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateActivityStatusApiV1ActivitiesActivityIdStatusPatch>>,
        TError,
        {activityId: string;params: UpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchParams},
        TContext
      > => {

      const mutationOptions = getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get the currently active activity for a session.
 * @summary Get Active Activity
 */
export type getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponse200 = {
  data: GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet200
  status: 200
}

export type getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponseSuccess = (getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponse200) & {
  headers: Headers;
};
export type getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponseError = (getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponse422) & {
  headers: Headers;
};

export type getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponse = (getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponseSuccess | getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponseError)

export const getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}/activities/active`
}

export const getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet = async (sessionId: number, options?: RequestInit): Promise<getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponse> => {

  return customFetcher<getActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponse>(getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetUrl(sessionId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetQueryKey = (sessionId?: number,) => {
    return [
    `/api/v1/sessions/${sessionId}/activities/active`
    ] as const;
    }


export const getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetQueryOptions = <TData = Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError = HTTPValidationError>(sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetQueryKey(sessionId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>> = ({ signal }) => getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet(sessionId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>>
export type GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetQueryError = HTTPValidationError


export function useGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet<TData = Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError = HTTPValidationError>(
 sessionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet<TData = Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError = HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet<TData = Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError = HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Active Activity
 */

export function useGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet<TData = Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError = HTTPValidationError>(
 sessionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveActivityApiV1SessionsSessionIdActivitiesActiveGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetQueryOptions(sessionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get activity status for real-time polling.
 * @summary Get Activity Status
 */
export type getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponse200 = {
  data: ActivityStatusResponse
  status: 200
}

export type getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponseSuccess = (getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponse200) & {
  headers: Headers;
};
export type getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponseError = (getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponse422) & {
  headers: Headers;
};

export type getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponse = (getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponseSuccess | getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponseError)

export const getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetUrl = (sessionId: number,
    activityId: string,) => {




  return `/api/v1/sessions/${sessionId}/activities/${activityId}/status`
}

export const getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet = async (sessionId: number,
    activityId: string, options?: RequestInit): Promise<getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponse> => {

  return customFetcher<getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponse>(getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetUrl(sessionId,activityId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetQueryKey = (sessionId?: number,
    activityId?: string,) => {
    return [
    `/api/v1/sessions/${sessionId}/activities/${activityId}/status`
    ] as const;
    }


export const getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError = HTTPValidationError>(sessionId: number,
    activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetQueryKey(sessionId,activityId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>> = ({ signal }) => getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet(sessionId,activityId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(sessionId && activityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>>
export type GetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetQueryError = HTTPValidationError


export function useGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet<TData = Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet<TData = Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet<TData = Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Activity Status
 */

export function useGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet<TData = Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError = HTTPValidationError>(
 sessionId: number,
    activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetQueryOptions(sessionId,activityId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new activity using the framework.
 * @summary Create Framework Activity
 */
export type createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponse201 = {
  data: Activity
  status: 201
}

export type createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponseSuccess = (createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponse201) & {
  headers: Headers;
};
export type createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponseError = (createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponse422) & {
  headers: Headers;
};

export type createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponse = (createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponseSuccess | createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponseError)

export const getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostUrl = (sessionId: number,) => {




  return `/api/v1/sessions/${sessionId}/activities/framework`
}

export const createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost = async (sessionId: number,
    frameworkActivityCreate: FrameworkActivityCreate, options?: RequestInit): Promise<createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponse> => {

  return customFetcher<createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponse>(getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostUrl(sessionId),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      frameworkActivityCreate,)
  }
);}




export const getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost>>, TError,{sessionId: number;data: FrameworkActivityCreate}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost>>, TError,{sessionId: number;data: FrameworkActivityCreate}, TContext> => {

const mutationKey = ['createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost>>, {sessionId: number;data: FrameworkActivityCreate}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost(sessionId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostMutationResult = NonNullable<Awaited<ReturnType<typeof createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost>>>
    export type CreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostMutationBody = FrameworkActivityCreate
    export type CreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostMutationError = HTTPValidationError

    /**
 * @summary Create Framework Activity
 */
export const useCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost>>, TError,{sessionId: number;data: FrameworkActivityCreate}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPost>>,
        TError,
        {sessionId: number;data: FrameworkActivityCreate},
        TContext
      > => {

      const mutationOptions = getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Transition activity state using the framework state machine.
 * @summary Transition Activity State
 */
export type transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponse200 = {
  data: Activity
  status: 200
}

export type transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponseSuccess = (transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponse200) & {
  headers: Headers;
};
export type transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponseError = (transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponse422) & {
  headers: Headers;
};

export type transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponse = (transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponseSuccess | transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponseError)

export const getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostUrl = (activityId: string,) => {




  return `/api/v1/activities/${activityId}/transition`
}

export const transitionActivityStateApiV1ActivitiesActivityIdTransitionPost = async (activityId: string,
    activityTransitionRequest: ActivityTransitionRequest, options?: RequestInit): Promise<transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponse> => {

  return customFetcher<transitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponse>(getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostUrl(activityId),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      activityTransitionRequest,)
  }
);}




export const getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transitionActivityStateApiV1ActivitiesActivityIdTransitionPost>>, TError,{activityId: string;data: ActivityTransitionRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof transitionActivityStateApiV1ActivitiesActivityIdTransitionPost>>, TError,{activityId: string;data: ActivityTransitionRequest}, TContext> => {

const mutationKey = ['transitionActivityStateApiV1ActivitiesActivityIdTransitionPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof transitionActivityStateApiV1ActivitiesActivityIdTransitionPost>>, {activityId: string;data: ActivityTransitionRequest}> = (props) => {
          const {activityId,data} = props ?? {};

          return  transitionActivityStateApiV1ActivitiesActivityIdTransitionPost(activityId,data,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type TransitionActivityStateApiV1ActivitiesActivityIdTransitionPostMutationResult = NonNullable<Awaited<ReturnType<typeof transitionActivityStateApiV1ActivitiesActivityIdTransitionPost>>>
    export type TransitionActivityStateApiV1ActivitiesActivityIdTransitionPostMutationBody = ActivityTransitionRequest
    export type TransitionActivityStateApiV1ActivitiesActivityIdTransitionPostMutationError = HTTPValidationError

    /**
 * @summary Transition Activity State
 */
export const useTransitionActivityStateApiV1ActivitiesActivityIdTransitionPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof transitionActivityStateApiV1ActivitiesActivityIdTransitionPost>>, TError,{activityId: string;data: ActivityTransitionRequest}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof transitionActivityStateApiV1ActivitiesActivityIdTransitionPost>>,
        TError,
        {activityId: string;data: ActivityTransitionRequest},
        TContext
      > => {

      const mutationOptions = getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Submit a participant response using the framework.
 * @summary Submit Activity Response
 */
export type submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponse200 = {
  data: unknown
  status: 200
}

export type submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponseSuccess = (submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponse200) & {
  headers: Headers;
};
export type submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponseError = (submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponse422) & {
  headers: Headers;
};

export type submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponse = (submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponseSuccess | submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponseError)

export const getSubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostUrl = (activityId: string,
    params: SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/activities/${activityId}/responses?${stringifiedParams}` : `/api/v1/activities/${activityId}/responses`
}

export const submitActivityResponseApiV1ActivitiesActivityIdResponsesPost = async (activityId: string,
    activityResponseSubmissionRequest: ActivityResponseSubmissionRequest,
    params: SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams, options?: RequestInit): Promise<submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponse> => {

  return customFetcher<submitActivityResponseApiV1ActivitiesActivityIdResponsesPostResponse>(getSubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostUrl(activityId,params),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      activityResponseSubmissionRequest,)
  }
);}




export const getSubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitActivityResponseApiV1ActivitiesActivityIdResponsesPost>>, TError,{activityId: string;data: ActivityResponseSubmissionRequest;params: SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof submitActivityResponseApiV1ActivitiesActivityIdResponsesPost>>, TError,{activityId: string;data: ActivityResponseSubmissionRequest;params: SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams}, TContext> => {

const mutationKey = ['submitActivityResponseApiV1ActivitiesActivityIdResponsesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitActivityResponseApiV1ActivitiesActivityIdResponsesPost>>, {activityId: string;data: ActivityResponseSubmissionRequest;params: SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams}> = (props) => {
          const {activityId,data,params} = props ?? {};

          return  submitActivityResponseApiV1ActivitiesActivityIdResponsesPost(activityId,data,params,requestOptions)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostMutationResult = NonNullable<Awaited<ReturnType<typeof submitActivityResponseApiV1ActivitiesActivityIdResponsesPost>>>
    export type SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostMutationBody = ActivityResponseSubmissionRequest
    export type SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostMutationError = HTTPValidationError

    /**
 * @summary Submit Activity Response
 */
export const useSubmitActivityResponseApiV1ActivitiesActivityIdResponsesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitActivityResponseApiV1ActivitiesActivityIdResponsesPost>>, TError,{activityId: string;data: ActivityResponseSubmissionRequest;params: SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams}, TContext>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof submitActivityResponseApiV1ActivitiesActivityIdResponsesPost>>,
        TError,
        {activityId: string;data: ActivityResponseSubmissionRequest;params: SubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostParams},
        TContext
      > => {

      const mutationOptions = getSubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Get calculated results for an activity.
 * @summary Get Activity Results
 */
export type getActivityResultsApiV1ActivitiesActivityIdResultsGetResponse200 = {
  data: ActivityResultsResponse
  status: 200
}

export type getActivityResultsApiV1ActivitiesActivityIdResultsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getActivityResultsApiV1ActivitiesActivityIdResultsGetResponseSuccess = (getActivityResultsApiV1ActivitiesActivityIdResultsGetResponse200) & {
  headers: Headers;
};
export type getActivityResultsApiV1ActivitiesActivityIdResultsGetResponseError = (getActivityResultsApiV1ActivitiesActivityIdResultsGetResponse422) & {
  headers: Headers;
};

export type getActivityResultsApiV1ActivitiesActivityIdResultsGetResponse = (getActivityResultsApiV1ActivitiesActivityIdResultsGetResponseSuccess | getActivityResultsApiV1ActivitiesActivityIdResultsGetResponseError)

export const getGetActivityResultsApiV1ActivitiesActivityIdResultsGetUrl = (activityId: string,) => {




  return `/api/v1/activities/${activityId}/results`
}

export const getActivityResultsApiV1ActivitiesActivityIdResultsGet = async (activityId: string, options?: RequestInit): Promise<getActivityResultsApiV1ActivitiesActivityIdResultsGetResponse> => {

  return customFetcher<getActivityResultsApiV1ActivitiesActivityIdResultsGetResponse>(getGetActivityResultsApiV1ActivitiesActivityIdResultsGetUrl(activityId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetActivityResultsApiV1ActivitiesActivityIdResultsGetQueryKey = (activityId?: string,) => {
    return [
    `/api/v1/activities/${activityId}/results`
    ] as const;
    }


export const getGetActivityResultsApiV1ActivitiesActivityIdResultsGetQueryOptions = <TData = Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError = HTTPValidationError>(activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActivityResultsApiV1ActivitiesActivityIdResultsGetQueryKey(activityId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>> = ({ signal }) => getActivityResultsApiV1ActivitiesActivityIdResultsGet(activityId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(activityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActivityResultsApiV1ActivitiesActivityIdResultsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>>
export type GetActivityResultsApiV1ActivitiesActivityIdResultsGetQueryError = HTTPValidationError


export function useGetActivityResultsApiV1ActivitiesActivityIdResultsGet<TData = Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError = HTTPValidationError>(
 activityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityResultsApiV1ActivitiesActivityIdResultsGet<TData = Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>,
          TError,
          Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActivityResultsApiV1ActivitiesActivityIdResultsGet<TData = Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Activity Results
 */

export function useGetActivityResultsApiV1ActivitiesActivityIdResultsGet<TData = Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActivityResultsApiV1ActivitiesActivityIdResultsGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActivityResultsApiV1ActivitiesActivityIdResultsGetQueryOptions(activityId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get enhanced activity status with framework information.
 * @summary Get Framework Activity Status
 */
export type getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponse200 = {
  data: FrameworkActivityStatusResponse
  status: 200
}

export type getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponseSuccess = (getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponse200) & {
  headers: Headers;
};
export type getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponseError = (getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponse422) & {
  headers: Headers;
};

export type getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponse = (getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponseSuccess | getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponseError)

export const getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetUrl = (activityId: string,) => {




  return `/api/v1/activities/${activityId}/status/framework`
}

export const getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet = async (activityId: string, options?: RequestInit): Promise<getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponse> => {

  return customFetcher<getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponse>(getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetUrl(activityId),
  {
    ...options,
    method: 'GET'


  }
);}





export const getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetQueryKey = (activityId?: string,) => {
    return [
    `/api/v1/activities/${activityId}/status/framework`
    ] as const;
    }


export const getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetQueryOptions = <TData = Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError = HTTPValidationError>(activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetQueryKey(activityId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>> = ({ signal }) => getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet(activityId, { signal, ...requestOptions });





   return  { queryKey, queryFn, enabled: !!(activityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetQueryResult = NonNullable<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>>
export type GetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetQueryError = HTTPValidationError


export function useGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet<TData = Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError = HTTPValidationError>(
 activityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>,
          TError,
          Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet<TData = Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>,
          TError,
          Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet<TData = Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Framework Activity Status
 */

export function useGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet<TData = Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError = HTTPValidationError>(
 activityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetQueryOptions(activityId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Root endpoint.
 * @summary Root
 */
export type rootGetResponse200 = {
  data: unknown
  status: 200
}

export type rootGetResponseSuccess = (rootGetResponse200) & {
  headers: Headers;
};
;

export type rootGetResponse = (rootGetResponseSuccess)

export const getRootGetUrl = () => {




  return `/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {

  return customFetcher<rootGetResponse>(getRootGetUrl(),
  {
    ...options,
    method: 'GET'


  }
);}





export const getRootGetQueryKey = () => {
    return [
    `/`
    ] as const;
    }


export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet({ signal, ...requestOptions });





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const getHealthCheckApiV1HealthGetResponseMock = (overrideResponse: Partial< HealthResponse > = {}): HealthResponse => ({status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), timestamp: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), version: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getReadinessCheckApiV1HealthReadyGetResponseMock = (overrideResponse: Partial< HealthResponse > = {}): HealthResponse => ({status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), timestamp: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), version: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getLivenessCheckApiV1HealthLiveGetResponseMock = (overrideResponse: Partial< HealthResponse > = {}): HealthResponse => ({status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), timestamp: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), version: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getCreateSessionApiV1SessionsPostResponseMock = (overrideResponse: Partial< SessionResponse > = {}): SessionResponse => ({id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), status: faker.helpers.arrayElement(Object.values(SessionStatus)), qr_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), admin_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), max_participants: faker.number.int({min: undefined, max: undefined}), started_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), participant_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), activity_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getListSessionsApiV1SessionsGetResponseMock = (overrideResponse: Partial< SessionList > = {}): SessionList => ({sessions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), status: faker.helpers.arrayElement(Object.values(SessionStatus)), qr_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), admin_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), max_participants: faker.number.int({min: undefined, max: undefined}), started_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), participant_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), activity_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), total: faker.number.int({min: undefined, max: undefined}), offset: faker.number.int({min: undefined, max: undefined}), limit: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getGetSessionApiV1SessionsSessionIdGetResponseMock = (overrideResponse: Partial< SessionDetail > = {}): SessionDetail => ({id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), status: faker.helpers.arrayElement(Object.values(SessionStatus)), qr_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), admin_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), max_participants: faker.number.int({min: undefined, max: undefined}), started_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), participant_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), activity_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), activities: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, session_id: faker.number.int({min: undefined, max: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), activity_type: faker.helpers.arrayElement(Object.values(ActivityType)), configuration: {}, is_active: faker.datatype.boolean(), order_index: faker.number.int({min: undefined, max: undefined}), started_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), response_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), undefined]), participants: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({participant_id: faker.string.alpha({length: {min: 10, max: 20}}), nickname: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.string.alpha({length: {min: 10, max: 20}}), joined_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_seen: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), ...overrideResponse})

export const getUpdateSessionApiV1SessionsSessionIdPutResponseMock = (overrideResponse: Partial< SessionResponse > = {}): SessionResponse => ({id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), status: faker.helpers.arrayElement(Object.values(SessionStatus)), qr_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), admin_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), max_participants: faker.number.int({min: undefined, max: undefined}), started_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), participant_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), activity_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getGetSessionByCodeApiV1SessionsCodeCodeGetResponseMock = (overrideResponse: Partial< SessionResponse > = {}): SessionResponse => ({id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, title: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), status: faker.helpers.arrayElement(Object.values(SessionStatus)), qr_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), admin_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), max_participants: faker.number.int({min: undefined, max: undefined}), started_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), participant_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), activity_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getGetSessionStatusApiV1SessionsSessionIdStatusGetResponseMock = (overrideResponse: Partial< SessionStatusResponse > = {}): SessionStatusResponse => ({session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(SessionStatus)), current_activity_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(),null,]), undefined]), participant_count: faker.number.int({min: undefined, max: undefined}), last_updated: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getJoinSessionApiV1SessionsSessionIdJoinPostResponseMock = (overrideResponse: Partial< ParticipantJoinResponse > = {}): ParticipantJoinResponse => ({participant_id: faker.string.alpha({length: {min: 10, max: 20}}), session_state: {}, ...overrideResponse})

export const getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponseMock = (overrideResponse: Partial< NicknameValidationResponse > = {}): NicknameValidationResponse => ({available: faker.datatype.boolean(), suggested_nickname: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), ...overrideResponse})

export const getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponseMock = (overrideResponse: Partial< ParticipantHeartbeatResponse > = {}): ParticipantHeartbeatResponse => ({status: faker.string.alpha({length: {min: 10, max: 20}}), activity_context: {}, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponseMock = (overrideResponse: Partial< ParticipantListResponse > = {}): ParticipantListResponse => ({participants: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({participant_id: faker.string.alpha({length: {min: 10, max: 20}}), nickname: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.string.alpha({length: {min: 10, max: 20}}), joined_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_seen: `${faker.date.past().toISOString().split('.')[0]}Z`})), total_count: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponseMock = (overrideResponse: Partial< UserResponse > = {}): UserResponse => ({response_data: {}, id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), activity_id: faker.string.uuid(), participant_id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponseMock = (overrideResponse: Partial< UserResponseList > = {}): UserResponseList => ({responses: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({response_data: {}, id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), activity_id: faker.string.uuid(), participant_id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), summary: {total_responses: faker.number.int({min: undefined, max: undefined}), unique_participants: faker.number.int({min: undefined, max: undefined}), last_updated: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,])}, ...overrideResponse})

export const getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponseMock = (): GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet200 => (faker.helpers.arrayElement([{response_data: {}, id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), activity_id: faker.string.uuid(), participant_id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},null,]))

export const getUpdateResponseApiV1ResponsesResponseIdPutResponseMock = (overrideResponse: Partial< UserResponse > = {}): UserResponse => ({response_data: {}, id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), activity_id: faker.string.uuid(), participant_id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponseMock = (): UserResponse[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({response_data: {}, id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), activity_id: faker.string.uuid(), participant_id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})))

export const getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponseMock = (overrideResponse: Partial< IncrementalResponseList > = {}): IncrementalResponseList => ({items: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({response_data: {}, id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), activity_id: faker.string.uuid(), participant_id: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), since: `${faker.date.past().toISOString().split('.')[0]}Z`, count: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getCreateActivityApiV1SessionsSessionIdActivitiesPostResponseMock = (overrideResponse: Partial< Activity > = {}): Activity => ({type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponseMock = (overrideResponse: Partial< ActivityList > = {}): ActivityList => ({activities: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), total: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getGetActivityTypesApiV1ActivitiesTypesGetResponseMock = (overrideResponse: Partial< ActivityTypesListResponse > = {}): ActivityTypesListResponse => ({activity_types: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.string.alpha({length: {min: 10, max: 20}}), version: faker.string.alpha({length: {min: 10, max: 20}})})), ...overrideResponse})

export const getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponseMock = (overrideResponse: Partial< ActivityTypeSchemaResponse > = {}): ActivityTypeSchemaResponse => ({activity_type: faker.string.alpha({length: {min: 10, max: 20}}), schema: {}, ...overrideResponse})

export const getValidateActivityConfigurationApiV1ActivitiesValidatePostResponseMock = (overrideResponse: Partial< ActivityValidationResponse > = {}): ActivityValidationResponse => ({valid: faker.datatype.boolean(), errors: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), warnings: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getGetActivityApiV1ActivitiesActivityIdGetResponseMock = (overrideResponse: Partial< Activity > = {}): Activity => ({type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getUpdateActivityApiV1ActivitiesActivityIdPutResponseMock = (overrideResponse: Partial< Activity > = {}): Activity => ({type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponseMock = (overrideResponse: Partial< Activity > = {}): Activity => ({type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponseMock = (): GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet200 => (faker.helpers.arrayElement([{type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},null,]))

export const getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponseMock = (overrideResponse: Partial< ActivityStatusResponse > = {}): ActivityStatusResponse => ({activity_id: faker.string.uuid(), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), response_count: faker.number.int({min: undefined, max: undefined}), last_response_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined]), last_updated: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponseMock = (overrideResponse: Partial< Activity > = {}): Activity => ({type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponseMock = (overrideResponse: Partial< Activity > = {}): Activity => ({type: faker.string.alpha({length: {min: 10, max: 20}}), config: faker.helpers.arrayElement([{}, undefined]), order_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), id: faker.string.uuid(), session_id: faker.number.int({min: undefined, max: undefined}), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetActivityResultsApiV1ActivitiesActivityIdResultsGetResponseMock = (overrideResponse: Partial< ActivityResultsResponse > = {}): ActivityResultsResponse => ({results: {}, last_updated: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponseMock = (overrideResponse: Partial< FrameworkActivityStatusResponse > = {}): FrameworkActivityStatusResponse => ({activity_id: faker.string.uuid(), status: faker.helpers.arrayElement(Object.values(ActivityStatus)), state: faker.string.alpha({length: {min: 10, max: 20}}), response_count: faker.number.int({min: undefined, max: undefined}), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined]), activity_metadata: faker.helpers.arrayElement([{}, undefined]), valid_transitions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), results: faker.helpers.arrayElement([faker.helpers.arrayElement([null,]), undefined]), last_response_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined]), last_updated: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})


export const getHealthCheckApiV1HealthGetMockHandler = (overrideResponse?: HealthResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<HealthResponse> | HealthResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/health/', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getHealthCheckApiV1HealthGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getReadinessCheckApiV1HealthReadyGetMockHandler = (overrideResponse?: HealthResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<HealthResponse> | HealthResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/health/ready', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getReadinessCheckApiV1HealthReadyGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getLivenessCheckApiV1HealthLiveGetMockHandler = (overrideResponse?: HealthResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<HealthResponse> | HealthResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/health/live', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getLivenessCheckApiV1HealthLiveGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateSessionApiV1SessionsPostMockHandler = (overrideResponse?: SessionResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SessionResponse> | SessionResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/sessions/', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateSessionApiV1SessionsPostResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListSessionsApiV1SessionsGetMockHandler = (overrideResponse?: SessionList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SessionList> | SessionList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListSessionsApiV1SessionsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetSessionApiV1SessionsSessionIdGetMockHandler = (overrideResponse?: SessionDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SessionDetail> | SessionDetail), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetSessionApiV1SessionsSessionIdGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateSessionApiV1SessionsSessionIdPutMockHandler = (overrideResponse?: SessionResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SessionResponse> | SessionResponse), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/sessions/:sessionId', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateSessionApiV1SessionsSessionIdPutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteSessionApiV1SessionsSessionIdDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/sessions/:sessionId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,

      })
  }, options)
}

export const getGetSessionByCodeApiV1SessionsCodeCodeGetMockHandler = (overrideResponse?: SessionResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SessionResponse> | SessionResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/code/:code', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetSessionByCodeApiV1SessionsCodeCodeGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetSessionStatusApiV1SessionsSessionIdStatusGetMockHandler = (overrideResponse?: SessionStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SessionStatusResponse> | SessionStatusResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/status', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetSessionStatusApiV1SessionsSessionIdStatusGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getJoinSessionApiV1SessionsSessionIdJoinPostMockHandler = (overrideResponse?: ParticipantJoinResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ParticipantJoinResponse> | ParticipantJoinResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/sessions/:sessionId/join', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getJoinSessionApiV1SessionsSessionIdJoinPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetMockHandler = (overrideResponse?: NicknameValidationResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<NicknameValidationResponse> | NicknameValidationResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/nicknames/validate', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostMockHandler = (overrideResponse?: ParticipantHeartbeatResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ParticipantHeartbeatResponse> | ParticipantHeartbeatResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/participants/:participantId/heartbeat', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetMockHandler = (overrideResponse?: ParticipantListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ParticipantListResponse> | ParticipantListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/participants', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRemoveParticipantApiV1ParticipantsParticipantIdDeleteMockHandler = (overrideResponse?: unknown | void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<unknown | void> | unknown | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/participants/:participantId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,

      })
  }, options)
}

export const getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostMockHandler = (overrideResponse?: UserResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<UserResponse> | UserResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/sessions/:sessionId/activities/:activityId/responses', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetMockHandler = (overrideResponse?: UserResponseList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserResponseList> | UserResponseList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/activities/:activityId/responses', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetMockHandler = (overrideResponse?: GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet200> | GetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGet200), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/activities/:activityId/responses/:participantId', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateResponseApiV1ResponsesResponseIdPutMockHandler = (overrideResponse?: UserResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<UserResponse> | UserResponse), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/responses/:responseId', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateResponseApiV1ResponsesResponseIdPutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteResponseApiV1ResponsesResponseIdDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/responses/:responseId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,

      })
  }, options)
}

export const getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetMockHandler = (overrideResponse?: UserResponse[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserResponse[]> | UserResponse[]), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/participants/:participantId/responses', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetMockHandler = (overrideResponse?: IncrementalResponseList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<IncrementalResponseList> | IncrementalResponseList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/activities/:activityId/responses/since/:timestamp', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateActivityApiV1SessionsSessionIdActivitiesPostMockHandler = (overrideResponse?: Activity | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Activity> | Activity), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/sessions/:sessionId/activities', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateActivityApiV1SessionsSessionIdActivitiesPostResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetMockHandler = (overrideResponse?: ActivityList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivityList> | ActivityList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/activities', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetActivityTypesApiV1ActivitiesTypesGetMockHandler = (overrideResponse?: ActivityTypesListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivityTypesListResponse> | ActivityTypesListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/activities/types', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetActivityTypesApiV1ActivitiesTypesGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetMockHandler = (overrideResponse?: ActivityTypeSchemaResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivityTypeSchemaResponse> | ActivityTypeSchemaResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/activities/types/:activityType/schema', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getValidateActivityConfigurationApiV1ActivitiesValidatePostMockHandler = (overrideResponse?: ActivityValidationResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ActivityValidationResponse> | ActivityValidationResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/activities/validate', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getValidateActivityConfigurationApiV1ActivitiesValidatePostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetActivityApiV1ActivitiesActivityIdGetMockHandler = (overrideResponse?: Activity | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Activity> | Activity), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/activities/:activityId', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetActivityApiV1ActivitiesActivityIdGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateActivityApiV1ActivitiesActivityIdPutMockHandler = (overrideResponse?: Activity | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Activity> | Activity), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/activities/:activityId', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateActivityApiV1ActivitiesActivityIdPutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteActivityApiV1ActivitiesActivityIdDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/activities/:activityId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,

      })
  }, options)
}

export const getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchMockHandler = (overrideResponse?: Activity | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Activity> | Activity), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/activities/:activityId/status', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetMockHandler = (overrideResponse?: GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet200> | GetActiveActivityApiV1SessionsSessionIdActivitiesActiveGet200), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/activities/active', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetMockHandler = (overrideResponse?: ActivityStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivityStatusResponse> | ActivityStatusResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/sessions/:sessionId/activities/:activityId/status', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostMockHandler = (overrideResponse?: Activity | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Activity> | Activity), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/sessions/:sessionId/activities/framework', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostMockHandler = (overrideResponse?: Activity | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Activity> | Activity), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/activities/:activityId/transition', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getSubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/activities/:activityId/responses', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,

      })
  }, options)
}

export const getGetActivityResultsApiV1ActivitiesActivityIdResultsGetMockHandler = (overrideResponse?: ActivityResultsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivityResultsResponse> | ActivityResultsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/activities/:activityId/results', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetActivityResultsApiV1ActivitiesActivityIdResultsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetMockHandler = (overrideResponse?: FrameworkActivityStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FrameworkActivityStatusResponse> | FrameworkActivityStatusResponse), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/activities/:activityId/status/framework', async (info) => {await delay(1000);

    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRootGetMockHandler = (overrideResponse?: unknown | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<unknown> | unknown), options?: RequestHandlerOptions) => {
  return http.get('*/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,

      })
  }, options)
}
export const getCajaBackendMock = () => [
  getHealthCheckApiV1HealthGetMockHandler(),
  getReadinessCheckApiV1HealthReadyGetMockHandler(),
  getLivenessCheckApiV1HealthLiveGetMockHandler(),
  getCreateSessionApiV1SessionsPostMockHandler(),
  getListSessionsApiV1SessionsGetMockHandler(),
  getGetSessionApiV1SessionsSessionIdGetMockHandler(),
  getUpdateSessionApiV1SessionsSessionIdPutMockHandler(),
  getDeleteSessionApiV1SessionsSessionIdDeleteMockHandler(),
  getGetSessionByCodeApiV1SessionsCodeCodeGetMockHandler(),
  getGetSessionStatusApiV1SessionsSessionIdStatusGetMockHandler(),
  getJoinSessionApiV1SessionsSessionIdJoinPostMockHandler(),
  getValidateNicknameApiV1SessionsSessionIdNicknamesValidateGetMockHandler(),
  getUpdateHeartbeatApiV1ParticipantsParticipantIdHeartbeatPostMockHandler(),
  getGetSessionParticipantsApiV1SessionsSessionIdParticipantsGetMockHandler(),
  getRemoveParticipantApiV1ParticipantsParticipantIdDeleteMockHandler(),
  getCreateResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesPostMockHandler(),
  getGetActivityResponsesApiV1SessionsSessionIdActivitiesActivityIdResponsesGetMockHandler(),
  getGetParticipantResponseApiV1SessionsSessionIdActivitiesActivityIdResponsesParticipantIdGetMockHandler(),
  getUpdateResponseApiV1ResponsesResponseIdPutMockHandler(),
  getDeleteResponseApiV1ResponsesResponseIdDeleteMockHandler(),
  getGetParticipantResponsesApiV1SessionsSessionIdParticipantsParticipantIdResponsesGetMockHandler(),
  getGetResponsesSinceApiV1SessionsSessionIdActivitiesActivityIdResponsesSinceTimestampGetMockHandler(),
  getCreateActivityApiV1SessionsSessionIdActivitiesPostMockHandler(),
  getGetSessionActivitiesApiV1SessionsSessionIdActivitiesGetMockHandler(),
  getGetActivityTypesApiV1ActivitiesTypesGetMockHandler(),
  getGetActivityTypeSchemaApiV1ActivitiesTypesActivityTypeSchemaGetMockHandler(),
  getValidateActivityConfigurationApiV1ActivitiesValidatePostMockHandler(),
  getGetActivityApiV1ActivitiesActivityIdGetMockHandler(),
  getUpdateActivityApiV1ActivitiesActivityIdPutMockHandler(),
  getDeleteActivityApiV1ActivitiesActivityIdDeleteMockHandler(),
  getUpdateActivityStatusApiV1ActivitiesActivityIdStatusPatchMockHandler(),
  getGetActiveActivityApiV1SessionsSessionIdActivitiesActiveGetMockHandler(),
  getGetActivityStatusApiV1SessionsSessionIdActivitiesActivityIdStatusGetMockHandler(),
  getCreateFrameworkActivityApiV1SessionsSessionIdActivitiesFrameworkPostMockHandler(),
  getTransitionActivityStateApiV1ActivitiesActivityIdTransitionPostMockHandler(),
  getSubmitActivityResponseApiV1ActivitiesActivityIdResponsesPostMockHandler(),
  getGetActivityResultsApiV1ActivitiesActivityIdResultsGetMockHandler(),
  getGetFrameworkActivityStatusApiV1ActivitiesActivityIdStatusFrameworkGetMockHandler(),
  getRootGetMockHandler()
]
